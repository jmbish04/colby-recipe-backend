<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Colby Recipe Backend</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f8f9fb;
      --fg: #222;
      --card: #ffffffcc;
      --accent: #2563eb;
      --muted: #55627a;
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      flex-direction: column;
      line-height: 1.5;
    }

    header {
      padding: 1.5rem 1rem 1rem;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.75rem;
    }

    header p {
      margin: 0;
      max-width: 720px;
      color: var(--muted);
    }

    main {
      flex: 1;
      display: grid;
      gap: 1.5rem;
      padding: 1.5rem clamp(1rem, 5vw, 3rem) 2rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    section {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    section h2 {
      margin: 0;
      font-size: 1.25rem;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    ul {
      margin: 0;
      padding-left: 1.25rem;
    }

    .appliance-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .appliance-list li {
      background: rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .appliance-meta {
      display: grid;
      gap: 0.25rem;
    }

    .appliance-actions {
      display: flex;
      gap: 0.5rem;
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .tester form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }

    input[type="text"],
    input[type="url"],
    select,
    textarea {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(100, 116, 139, 0.35);
      font: inherit;
      background: rgba(255, 255, 255, 0.9);
      box-sizing: border-box;
    }

    textarea {
      min-height: 140px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Monaco, Consolas, monospace;
    }

    .headers {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .header-row {
      display: grid;
      grid-template-columns: minmax(110px, 1fr) minmax(120px, 1.5fr) auto;
      gap: 0.5rem;
      align-items: center;
    }

    .header-row input {
      width: 100%;
    }

    .header-row button {
      padding: 0.5rem;
      border: none;
      border-radius: 8px;
      background: rgba(148, 163, 184, 0.25);
      cursor: pointer;
    }

    .header-row button:hover {
      background: rgba(148, 163, 184, 0.4);
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .actions button {
      padding: 0.75rem 1.25rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
    }

    .actions button:disabled {
      opacity: 0.6;
      cursor: progress;
    }

    .response {
      background: rgba(15, 23, 42, 0.9);
      color: #f8fafc;
      padding: 1rem;
      border-radius: 12px;
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      overflow: hidden;
    }

    .response h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .response pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(148, 163, 184, 0.16);
      padding: 0.75rem;
      border-radius: 10px;
      max-height: 260px;
      overflow: auto;
    }

    footer {
      padding: 1rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (max-width: 720px) {
      main {
        grid-template-columns: 1fr;
      }

      .header-row {
        grid-template-columns: 1fr 1fr auto;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Colby Recipe Backend</h1>
    <p>Colby powers recipe ingestion, personalization, and menu planning for MenuForge. Use the authenticated REST API to scan recipes, manage favorites, build menus, and more. Explore the full schema in the <a href="/openapi.json">OpenAPI specification</a>.</p>
  </header>
  <main>
    <section>
      <h2>Quick Start</h2>
      <p>The Worker exposes a JSON API under <code>/api/</code> for recipes, favorites, menu generation, search utilities, and chat. Typical flow:</p>
      <ul>
        <li>Scan a recipe with <code>POST /api/recipes/scan</code> or <code>/batch-scan</code>.</li>
        <li>Query ranked recipes via <code>GET /api/recipes</code>.</li>
        <li>Track engagement with favorites, ratings, and custom events.</li>
        <li>Generate a weekly menu using <code>POST /api/menus/generate</code> with optional themes and exclusions.</li>
        <li>Keep pantry inventory in sync via <code>GET/POST/PUT/DELETE /api/pantry</code> and request a pantry-aware list with <code>POST /api/menus/{id}/shopping-list</code>.</li>
      </ul>
      <p>Responses are JSON unless otherwise noted (e.g., printable recipes return HTML). See <a href="/openapi.json">/openapi.json</a> for structured details.</p>
    </section>
    <section>
      <h2>Authentication</h2>
      <p>All API routes require the Worker API key.</p>
      <ul>
        <li><strong>Header:</strong> <code>Authorization: Bearer &lt;WORKER_API_KEY&gt;</code></li>
        <li><strong>or Header:</strong> <code>X-API-Key: &lt;WORKER_API_KEY&gt;</code></li>
      </ul>
      <p>When also sending user session tokens, prefer keeping <code>Authorization</code> for the session value and include the Worker key via <code>X-API-Key</code>. Unauthorized requests return <code>401</code> with <code>WWW-Authenticate: Bearer realm="worker"</code>. Store your key securely; the tester below keeps it in <code>localStorage</code> on this device only.</p>
    </section>
    <section class="tester">
      <h2>API Tester</h2>
      <form id="api-form">
        <div>
          <label for="path">Request path</label>
          <input id="path" name="path" type="text" value="/api/recipes" autocomplete="off" required>
        </div>
        <div>
          <label for="method">HTTP method</label>
          <select id="method" name="method">
            <option>GET</option>
            <option>POST</option>
            <option>PUT</option>
            <option>PATCH</option>
            <option>DELETE</option>
          </select>
        </div>
        <div>
          <label>Headers</label>
          <div class="headers" id="headers"></div>
          <div class="actions">
            <button type="button" id="add-header" style="background: rgba(148, 163, 184, 0.25); color: var(--fg);">Add header</button>
          </div>
        </div>
        <div>
          <label for="body">Request body (JSON)</label>
          <textarea id="body" name="body" placeholder='{"example":true}'></textarea>
        </div>
        <div class="actions">
          <button id="send" type="submit">Send request</button>
        </div>
      </form>
      <div class="response" id="response" hidden>
        <h3 id="response-status">Status</h3>
        <pre id="response-headers"></pre>
        <pre id="response-body"></pre>
      </div>
    </section>
    <section id="voice">
      <h2>Voice memo ‚Üí Ingredients</h2>
      <p>Record a short pantry rundown. We transcribe it and drop the text into the chat textarea.</p>
      <div class="row" style="align-items:center;">
        <button id="recordBtn">üéôÔ∏è Start recording</button>
        <span id="recordingStatus" class="pill" hidden>Recording‚Ä¶</span>
        <button id="stopBtn" class="secondary" disabled>‚èπ Stop</button>
      </div>
      <p id="transcribeResult"></p>
    </section>
  
    <section id="chat">
      <h2>On-hand chat</h2>
      <label for="ingredients">Ingredients (comma separated)</label>
      <textarea id="ingredients" placeholder="tomatoes, basil, mozzarella"></textarea>
      <label for="theme">Theme</label>
      <input id="theme" type="text" placeholder="e.g. summer picnic" />
      <div class="row">
        <div>
          <label for="userId">User ID (optional personalization)</label>
          <input id="userId" type="text" placeholder="household-123" />
        </div>
        <div>
          <label>Tools</label>
          <div class="tools">
            <label><input type="checkbox" value="air_fryer" class="toolChk" />Air fryer</label>
            <label><input type="checkbox" value="bread_machine" class="toolChk" />Bread machine</label>
            <label><input type="checkbox" value="slow_cooker" class="toolChk" />Slow cooker</label>
            <label><input type="checkbox" value="instant_pot" class="toolChk" />Instant Pot</label>
          </div>
        </div>
      </div>
      <button id="chatBtn">‚ú® Suggest recipes</button>
      <div id="chatOutput" style="margin-top:1rem;"></div>
    </section>
  
    <section id="ingestUrl">
      <h2>Ingest via URL</h2>
      <label for="urlInput">Recipe URL</label>
      <input id="urlInput" type="url" placeholder="https://example.com/my-favorite-recipe" />
      <button id="urlBtn">üåê Crawl &amp; normalize</button>
      <div id="urlResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="ingestImage">
      <h2>Ingest via image</h2>
      <p>Upload one or more recipe photos or scans. We run OCR and normalize the result.</p>
      <input id="imageInput" type="file" accept="image/*" multiple />
      <button id="imageBtn">üñºÔ∏è Normalize images</button>
      <div id="imageResult" style="margin-top:1rem;"></div>
    </section>

    <section id="appliances">
      <h2>Kitchen appliances</h2>
      <p>Upload manuals to personalize recipes for your gear. Manuals are stored securely in R2 and processed asynchronously.</p>
      <form id="applianceForm" class="stack">
        <div>
          <label for="applianceNickname">Nickname (optional)</label>
          <input id="applianceNickname" type="text" placeholder="e.g. My Air Fryer" />
        </div>
        <div>
          <label for="applianceManual">Manual upload (PDF)</label>
          <input id="applianceManual" type="file" accept="application/pdf" />
        </div>
        <div>
          <label for="applianceManualUrl">Manual URL (public PDF)</label>
          <input id="applianceManualUrl" type="url" placeholder="https://example.com/manual.pdf" />
        </div>
        <p class="muted">Provide either a manual file or a public manual URL.</p>
        <div class="row" style="align-items:center; gap:0.75rem;">
          <button type="submit">‚ûï Add appliance</button>
          <button type="button" id="refreshAppliances" class="secondary">üîÑ Refresh list</button>
        </div>
      </form>
      <div id="applianceResult" class="response" hidden>
        <h3>Latest appliance</h3>
        <pre id="applianceResultBody"></pre>
      </div>
      <div>
        <h3>Your appliances</h3>
        <ul id="appliancesList" class="appliance-list">
          <li class="muted">No appliances yet. Add one to get started.</li>
        </ul>
      </div>
    </section>

    <section id="recipeAgents">
      <h2>Agentic recipe tailoring</h2>
      <p>Load structured recipes, generate Mermaid flowcharts, and rewrite instructions for a specific appliance.</p>
      <div class="row">
        <div>
          <label for="tailorRecipeId">Recipe ID</label>
          <input id="tailorRecipeId" type="text" placeholder="recipe-123" />
        </div>
        <div>
          <label for="tailorApplianceId">Appliance ID</label>
          <input id="tailorApplianceId" type="text" placeholder="appliance-456" />
        </div>
      </div>
      <div class="row" style="align-items:center; gap:0.75rem;">
        <button id="loadRecipeDetail" class="secondary">üìÑ Load recipe detail</button>
        <button id="flowchartBtn" class="secondary">üìà Generate flowchart</button>
        <button id="tailorBtn">ü§ñ Tailor instructions</button>
        <button id="adaptBtn" class="secondary">‚ú® Adapt instructions</button>
      </div>
      <div id="recipeDetailResult" class="response" hidden>
        <h3>Recipe detail</h3>
        <pre></pre>
      </div>
      <div id="flowchartResult" class="response" hidden>
        <h3>Mermaid flowchart</h3>
        <pre></pre>
      </div>
      <div id="tailorResult" class="response" hidden>
        <h3>Tailored steps</h3>
        <pre></pre>
      </div>
      <div id="adaptResult" class="response" hidden>
        <h3>Adapted recipe</h3>
        <pre></pre>
      </div>
    </section>

    <section id="prefs">
      <h2>User preferences</h2>
      <div class="row">
        <div>
          <label for="prefsUser">User ID</label>
          <input id="prefsUser" type="text" placeholder="household-123" />
        </div>
        <div>
          <label for="prefsCuisines">Favored cuisines</label>
          <input id="prefsCuisines" type="text" placeholder="thai, mexican" />
        </div>
        <div>
          <label for="prefsDislikes">Disliked ingredients</label>
          <input id="prefsDislikes" type="text" placeholder="olives, cilantro" />
        </div>
        <div>
          <label for="prefsTools">Favored tools</label>
          <input id="prefsTools" type="text" placeholder="air_fryer, grill" />
        </div>
      </div>
      <label for="prefsNotes">Notes</label>
      <textarea id="prefsNotes" placeholder="Anything else to remember"></textarea>
      <div class="row" style="margin-top:0.75rem;">
        <button id="loadPrefs">üì• Load</button>
        <button id="savePrefs" class="secondary">üíæ Save</button>
      </div>
      <div id="prefsResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="themes">
      <h2>Theme suggestions</h2>
      <label for="themeSeed">Theme seed</label>
      <input id="themeSeed" type="text" placeholder="peach" />
      <button id="themeBtn">üçë Fetch ideas</button>
      <div id="themeResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="logs">
      <h2>Request logs</h2>
      <div class="row" style="align-items:center;">
        <div>
          <label for="logLimit">Limit</label>
          <input id="logLimit" type="text" value="50" />
        </div>
        <div>
          <label for="logLevel">Level</label>
          <input id="logLevel" type="text" placeholder="info | error" />
        </div>
        <button id="refreshLogs">üîÑ Refresh</button>
      </div>
      <div style="overflow-x:auto; max-height:320px;">
        <table>
          <thead>
            <tr><th>Timestamp</th><th>Level</th><th>Route</th><th>Method</th><th>Status</th><th>ms</th><th>Message</th><th>Meta</th></tr>
          </thead>
          <tbody id="logsBody"></tbody>
        </table>
      </div>
    </section>
  </main>
  <footer>
    Built for MenuForge ‚Ä¢ Need schema details? <a href="/openapi.json">Download the OpenAPI document</a>.
  </footer>
  <script>
    const headersContainer = document.getElementById('headers');
    const addHeaderBtn = document.getElementById('add-header');
    const apiForm = document.getElementById('api-form');
    const methodSelect = document.getElementById('method');
    const bodyField = document.getElementById('body');
    const sendBtn = document.getElementById('send');
    const responseCard = document.getElementById('response');
    const responseStatus = document.getElementById('response-status');
    const responseHeaders = document.getElementById('response-headers');
    const responseBody = document.getElementById('response-body');
    const API_KEY_STORAGE = 'colby-api-key';

    function createHeaderRow(key = '', value = '', options = {}) {
      const row = document.createElement('div');
      row.className = 'header-row';

      const keyInput = document.createElement('input');
      keyInput.className = 'header-key';
      keyInput.type = 'text';
      keyInput.placeholder = 'Header name';
      keyInput.value = key;
      if (options.readonlyKey) {
        keyInput.readOnly = true;
        keyInput.tabIndex = -1;
        keyInput.style.background = 'rgba(148, 163, 184, 0.15)';
      }

      const valueInput = document.createElement('input');
      valueInput.className = 'header-value';
      valueInput.type = 'text';
      valueInput.placeholder = 'Header value';
      valueInput.value = value;

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = '‚úï';
      removeBtn.title = 'Remove header';
      removeBtn.addEventListener('click', () => row.remove());

      if (options.locked) {
        removeBtn.disabled = true;
        removeBtn.style.visibility = 'hidden';
      }

      row.appendChild(keyInput);
      row.appendChild(valueInput);
      row.appendChild(removeBtn);

      if (options.storageKey) {
        const saved = localStorage.getItem(options.storageKey);
        if (saved) {
          valueInput.value = saved;
        }
        valueInput.addEventListener('input', () => {
          localStorage.setItem(options.storageKey, valueInput.value);
        });
      }

      headersContainer.appendChild(row);
      return row;
    }

    createHeaderRow('X-API-Key', '', { storageKey: API_KEY_STORAGE });
    createHeaderRow('Content-Type', 'application/json');

    addHeaderBtn.addEventListener('click', () => {
      createHeaderRow();
    });

    methodSelect.addEventListener('change', () => {
      const method = methodSelect.value.toUpperCase();
      const allowBody = !['GET', 'HEAD'].includes(method);
      bodyField.disabled = !allowBody;
      if (!allowBody) {
        bodyField.placeholder = 'Request body not sent for ' + method + ' requests';
      } else {
        bodyField.placeholder = '{"example":true}';
      }
    });

    apiForm.addEventListener('submit', async (event) => {
      event.preventDefault();

      const rawPath = document.getElementById('path').value.trim();
      const method = methodSelect.value.toUpperCase();
      const headers = new Headers();

      headersContainer.querySelectorAll('.header-row').forEach((row) => {
        const key = row.querySelector('.header-key').value.trim();
        const value = row.querySelector('.header-value').value;
        if (key) {
          headers.set(key, value);
        }
      });

      let url;
      if (/^https?:\/\//i.test(rawPath)) {
        url = rawPath;
      } else {
        const normalized = rawPath.startsWith('/') ? rawPath : `/${rawPath}`;
        url = new URL(normalized, window.location.origin).toString();
      }

      let body = undefined;
      if (!['GET', 'HEAD'].includes(method)) {
        const content = bodyField.value.trim();
        if (content) {
          try {
            body = JSON.stringify(JSON.parse(content));
          } catch (error) {
            alert('Request body must be valid JSON.');
            return;
          }
        }
      }

      sendBtn.disabled = true;
      sendBtn.textContent = 'Sending‚Ä¶';
      responseCard.hidden = false;
      responseStatus.textContent = 'Awaiting response‚Ä¶';
      responseHeaders.textContent = '';
      responseBody.textContent = '';

      try {
        const res = await fetch(url, { method, headers, body });
        const statusLine = `${res.status} ${res.statusText}`;
        responseStatus.textContent = `Status: ${statusLine}`;

        const headerEntries = Array.from(res.headers.entries())
          .map(([k, v]) => `${k}: ${v}`)
          .join('\n');
        responseHeaders.textContent = headerEntries || '(no headers)';

        const text = await res.text();
        let formatted = text;
        try {
          formatted = JSON.stringify(JSON.parse(text), null, 2);
        } catch (error) {
          // Not JSON; leave as text
        }
        responseBody.textContent = formatted || '(empty body)';
      } catch (error) {
        responseStatus.textContent = 'Request failed';
        responseHeaders.textContent = '';
        responseBody.textContent = String(error);
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send request';
      }
    });

    const apiKeyInput = document.getElementById('apiKey');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordingStatus = document.getElementById('recordingStatus');
    const transcribeResult = document.getElementById('transcribeResult');
    const ingredientsInput = document.getElementById('ingredients');
    const chatBtn = document.getElementById('chatBtn');
    const chatOutput = document.getElementById('chatOutput');
    const urlBtn = document.getElementById('urlBtn');
    const urlInput = document.getElementById('urlInput');
    const urlResult = document.getElementById('urlResult');
    const imageBtn = document.getElementById('imageBtn');
    const imageInput = document.getElementById('imageInput');
    const imageResult = document.getElementById('imageResult');
    const prefsUser = document.getElementById('prefsUser');
    const prefsCuisines = document.getElementById('prefsCuisines');
    const prefsDislikes = document.getElementById('prefsDislikes');
    const prefsTools = document.getElementById('prefsTools');
    const prefsNotes = document.getElementById('prefsNotes');
    const prefsResult = document.getElementById('prefsResult');
    const loadPrefs = document.getElementById('loadPrefs');
    const savePrefs = document.getElementById('savePrefs');
    const themeSeed = document.getElementById('themeSeed');
    const themeBtn = document.getElementById('themeBtn');
    const themeResult = document.getElementById('themeResult');
    const logsBody = document.getElementById('logsBody');
    const refreshLogs = document.getElementById('refreshLogs');
    const logLimit = document.getElementById('logLimit');
    const logLevel = document.getElementById('logLevel');
    const userIdInput = document.getElementById('userId');
    const toolCheckboxes = Array.from(document.querySelectorAll('.toolChk'));
    const themeInput = document.getElementById('theme');
    const applianceForm = document.getElementById('applianceForm');
    const applianceNickname = document.getElementById('applianceNickname');
    const applianceManual = document.getElementById('applianceManual');
    const applianceManualUrl = document.getElementById('applianceManualUrl');
    const applianceResult = document.getElementById('applianceResult');
    const applianceResultBody = document.getElementById('applianceResultBody');
    const appliancesList = document.getElementById('appliancesList');
    const refreshAppliances = document.getElementById('refreshAppliances');
    const recipeDetailResult = document.getElementById('recipeDetailResult');
    const recipeDetailPre = recipeDetailResult?.querySelector('pre');
    const flowchartResult = document.getElementById('flowchartResult');
    const flowchartPre = flowchartResult?.querySelector('pre');
    const tailorResult = document.getElementById('tailorResult');
    const tailorPre = tailorResult?.querySelector('pre');
    const adaptResult = document.getElementById('adaptResult');
    const adaptPre = adaptResult?.querySelector('pre');
    const loadRecipeDetailBtn = document.getElementById('loadRecipeDetail');
    const flowchartBtn = document.getElementById('flowchartBtn');
    const tailorBtnAgent = document.getElementById('tailorBtn');
    const adaptBtn = document.getElementById('adaptBtn');
    const tailorRecipeId = document.getElementById('tailorRecipeId');
    const tailorApplianceId = document.getElementById('tailorApplianceId');

    const storageKey = 'menuforge-api-key';
    
    function authHeaders(extra = {}) {
      const key = localStorage.getItem(API_KEY_STORAGE) || '';
      if (!key) throw new Error('API key required');
      return Object.assign({ 'X-API-Key': key }, extra);
    }

    function escapeHtml(value) {
      const str = value == null ? '' : String(value);
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function callJson(url, options = {}) {
      const res = await fetch(url, options);
      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(data.error || res.statusText);
      return data;
    }

    async function handleChat() {
      try {
        chatBtn.disabled = true;
        chatOutput.innerHTML = 'Loading‚Ä¶';
        const tools = toolCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        const payload = {
          ingredients: ingredientsInput.value.split(',').map(s => s.trim()).filter(Boolean),
          theme: themeInput.value.trim() || undefined,
          tools,
          userId: userIdInput.value.trim() || undefined,
        };
        const data = await callJson('/api/chat/ingredients', {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        chatOutput.innerHTML = `
          <h3>Assistant message</h3>
          <pre>${data.message || ''}</pre>
          <h3>Suggestions</h3>
          <ol>${(data.suggestions || []).map(r => `<li><strong>${r.title}</strong> <small>${(r.cuisine || '')}</small><br/><span class="pill">${(r.tags || []).join(', ')}</span></li>`).join('')}</ol>
        `;
      } catch (err) {
        chatOutput.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        chatBtn.disabled = false;
      }
    }
    chatBtn.addEventListener('click', handleChat);

    async function handleUrl() {
      try {
        urlBtn.disabled = true;
        urlResult.textContent = 'Loading‚Ä¶';
        const data = await callJson('/api/ingest/url', {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ url: urlInput.value.trim() }),
        });
        urlResult.innerHTML = `<pre>${JSON.stringify(data.recipe, null, 2)}</pre>`;
      } catch (err) {
        urlResult.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        urlBtn.disabled = false;
      }
    }
    urlBtn.addEventListener('click', handleUrl);

    async function handleImages() {
      try {
        imageBtn.disabled = true;
        imageResult.textContent = 'Loading‚Ä¶';
        const form = new FormData();
        Array.from(imageInput.files || []).forEach(file => form.append('file', file));
        const res = await fetch('/api/ingest/image', {
          method: 'POST',
          headers: authHeaders(),
          body: form,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        imageResult.innerHTML = `<pre>${JSON.stringify(data.recipe, null, 2)}</pre>`;
      } catch (err) {
        imageResult.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        imageBtn.disabled = false;
      }
    }
    imageBtn.addEventListener('click', handleImages);

    async function loadAppliancesList() {
      if (!appliancesList) return;
      try {
        refreshAppliances && (refreshAppliances.disabled = true);
        const data = await callJson('/api/kitchen/appliances', { headers: authHeaders() });
        const items = data.appliances || [];
        if (!items.length) {
          appliancesList.innerHTML = '<li class="muted">No appliances yet. Add one to get started.</li>';
          return;
        }
        appliancesList.innerHTML = items
          .map((appliance) => {
            const specs = appliance.extractedSpecs || {};
            const displayName =
              appliance.nickname ||
              [appliance.brand || specs.brand, appliance.model || specs.model]
                .filter(Boolean)
                .join(' ') ||
              'Untitled appliance';
            const status = appliance.processingStatus || 'QUEUED';
            const safeStatus = escapeHtml(status);
            const manualKey = appliance.manualR2Key
              ? `Manual key: ${escapeHtml(appliance.manualR2Key)}`
              : 'Manual pending upload';
            const textKey = appliance.ocrTextR2Key ? `Text key: ${escapeHtml(appliance.ocrTextR2Key)}` : '';
            const features = Array.isArray(specs.keyFeatures) && specs.keyFeatures.length
              ? `<small>Features: ${specs.keyFeatures.map((f) => escapeHtml(f)).join(', ')}</small>`
              : '';
            const instructions = appliance.agentInstructions
              ? `<details><summary>Agent instructions</summary><pre>${escapeHtml(appliance.agentInstructions)}</pre></details>`
              : '';
            const statusButton = status === 'COMPLETED'
              ? ''
              : `<button data-action="status" data-id="${escapeHtml(appliance.id)}" class="secondary">üì° Check status</button>`;
            return `
              <li>
                <div class="appliance-meta">
                  <strong>${escapeHtml(displayName)}</strong>
                  <span class="pill">${safeStatus}</span>
                  <small>ID: ${escapeHtml(appliance.id)}</small>
                  <small>${manualKey}${textKey ? ` ¬∑ ${textKey}` : ''}</small>
                  ${features}
                  ${instructions}
                </div>
                <div class="appliance-actions">
                  ${statusButton}
                  <button data-action="delete" data-id="${appliance.id}" class="secondary">üóë Remove</button>
                </div>
              </li>`;
          })
          .join('');
      } catch (err) {
        appliancesList.innerHTML = `<li><pre>${err.message}</pre></li>`;
      } finally {
        refreshAppliances && (refreshAppliances.disabled = false);
      }
    }

    async function handleApplianceSubmit(event) {
      event.preventDefault();
      if (!applianceForm) return;
      try {
        applianceForm.querySelector('button[type="submit"]').disabled = true;
        const form = new FormData();
        const nickname = applianceNickname?.value.trim();
        const manualUrlValue = applianceManualUrl?.value.trim();
        const manualFile = applianceManual?.files && applianceManual.files[0];

        if (!manualFile && !manualUrlValue) {
          throw new Error('Provide a manual file or manual URL');
        }

        if (nickname) {
          form.append('nickname', nickname);
        }
        if (manualFile) {
          form.append('manual_file', manualFile);
        }
        if (manualUrlValue) {
          form.append('manual_url', manualUrlValue);
        }
        const res = await fetch('/api/kitchen/appliances', {
          method: 'POST',
          headers: authHeaders(),
          body: form,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        if (applianceResult && applianceResultBody) {
          applianceResult.hidden = false;
          applianceResultBody.textContent = JSON.stringify(data, null, 2);
        }
        applianceForm.reset();
        await loadAppliancesList();
      } catch (err) {
        if (applianceResult && applianceResultBody) {
          applianceResult.hidden = false;
          applianceResultBody.textContent = err.message;
        }
      } finally {
        const submitBtn = applianceForm.querySelector('button[type="submit"]');
        submitBtn && (submitBtn.disabled = false);
      }
    }

    async function handleDeleteAppliance(id) {
      try {
        await callJson(`/api/kitchen/appliances/${id}`, {
          method: 'DELETE',
          headers: authHeaders(),
        });
        await loadAppliancesList();
      } catch (err) {
        alert(err.message);
      }
    }

    async function handleApplianceStatus(id) {
      try {
        const data = await callJson(`/api/kitchen/appliances/${id}/status`, {
          headers: authHeaders(),
        });
        alert(`Status: ${data.status}`);
        await loadAppliancesList();
      } catch (err) {
        alert(err.message);
      }
    }

    appliancesList?.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const id = target.dataset.id;
      if (target.dataset.action === 'delete' && id) {
        handleDeleteAppliance(id);
      }
      if (target.dataset.action === 'status' && id) {
        handleApplianceStatus(id);
      }
    });

    applianceForm?.addEventListener('submit', handleApplianceSubmit);
    refreshAppliances?.addEventListener('click', loadAppliancesList);

    async function handleRecipeDetailLoad() {
      if (!recipeDetailResult || !recipeDetailPre) return;
      try {
        loadRecipeDetailBtn.disabled = true;
        recipeDetailResult.hidden = false;
        recipeDetailPre.textContent = 'Loading‚Ä¶';
        const id = tailorRecipeId.value.trim();
        if (!id) throw new Error('Recipe ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(id)}`, {
          headers: authHeaders(),
        });
        recipeDetailPre.textContent = JSON.stringify(data.recipe, null, 2);
      } catch (err) {
        recipeDetailPre.textContent = err.message;
      } finally {
        loadRecipeDetailBtn.disabled = false;
      }
    }

    loadRecipeDetailBtn?.addEventListener('click', handleRecipeDetailLoad);

    async function handleFlowchart() {
      if (!flowchartResult || !flowchartPre) return;
      try {
        flowchartBtn.disabled = true;
        flowchartResult.hidden = false;
        flowchartPre.textContent = 'Loading‚Ä¶';
        const id = tailorRecipeId.value.trim();
        if (!id) throw new Error('Recipe ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(id)}/flowchart`, {
          headers: authHeaders(),
        });
        flowchartPre.textContent = data.flowchart || '';
      } catch (err) {
        flowchartPre.textContent = err.message;
      } finally {
        flowchartBtn.disabled = false;
      }
    }

    flowchartBtn?.addEventListener('click', handleFlowchart);

    async function handleTailorRecipe() {
      if (!tailorResult || !tailorPre) return;
      try {
        tailorBtnAgent.disabled = true;
        tailorResult.hidden = false;
        tailorPre.textContent = 'Loading‚Ä¶';
        const recipeId = tailorRecipeId.value.trim();
        const applianceId = tailorApplianceId.value.trim();
        if (!recipeId) throw new Error('Recipe ID required');
        if (!applianceId) throw new Error('Appliance ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(recipeId)}/tailor`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ appliance_id: applianceId }),
        });
        const steps = data.tailored_steps || [];
        tailorPre.textContent = steps.length ? steps.map((step, index) => `${index + 1}. ${step}`).join('\n') : 'No steps returned.';
      } catch (err) {
        tailorPre.textContent = err.message;
      } finally {
        tailorBtnAgent.disabled = false;
      }
    }

    tailorBtnAgent?.addEventListener('click', handleTailorRecipe);

    async function handleAdaptRecipe() {
      if (!adaptResult || !adaptPre) return;
      try {
        adaptBtn.disabled = true;
        adaptResult.hidden = false;
        adaptPre.textContent = 'Loading‚Ä¶';
        const recipeId = tailorRecipeId.value.trim();
        const applianceId = tailorApplianceId.value.trim();
        if (!recipeId) throw new Error('Recipe ID required');
        if (!applianceId) throw new Error('Appliance ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(recipeId)}/adapt`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ appliance_id: applianceId }),
        });
        const steps = data.tailored_steps || [];
        const summary = data.summary_of_changes || '';
        const stepsText = steps.length
          ? steps.map((step, index) => `${index + 1}. ${step}`).join('\n')
          : 'No steps returned.';
        adaptPre.textContent = `${summary ? `Summary: ${summary}\n\n` : ''}${stepsText}`;
      } catch (err) {
        adaptPre.textContent = err.message;
      } finally {
        adaptBtn.disabled = false;
      }
    }

    adaptBtn?.addEventListener('click', handleAdaptRecipe);

    async function handlePrefsLoad() {
      try {
        prefsResult.textContent = 'Loading‚Ä¶';
        const params = new URLSearchParams({ userId: prefsUser.value.trim() });
        const data = await callJson(`/api/prefs?${params.toString()}`, { headers: authHeaders() });
        const prefs = data.preferences || {};
        prefsCuisines.value = (prefs.cuisines || []).join(', ');
        prefsDislikes.value = (prefs.dislikedIngredients || []).join(', ');
        prefsTools.value = (prefs.favoredTools || []).join(', ');
        prefsNotes.value = prefs.notes || '';
        prefsResult.innerHTML = `<pre>${JSON.stringify(prefs, null, 2)}</pre>`;
      } catch (err) {
        prefsResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    loadPrefs.addEventListener('click', handlePrefsLoad);

    async function handlePrefsSave() {
      try {
        prefsResult.textContent = 'Saving‚Ä¶';
        const payload = {
          userId: prefsUser.value.trim(),
          cuisines: prefsCuisines.value,
          dislikedIngredients: prefsDislikes.value,
          favoredTools: prefsTools.value,
          notes: prefsNotes.value,
        };
        const data = await callJson('/api/prefs', {
          method: 'PUT',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        prefsResult.innerHTML = `<pre>${JSON.stringify(data.preferences, null, 2)}</pre>`;
      } catch (err) {
        prefsResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    savePrefs.addEventListener('click', handlePrefsSave);

    async function handleTheme() {
      try {
        themeResult.textContent = 'Loading‚Ä¶';
        const params = new URLSearchParams({ seed: themeSeed.value.trim() });
        const data = await callJson(`/api/themes/suggest?${params.toString()}`, { headers: authHeaders() });
        themeResult.innerHTML = `<ol>${(data.recipes || []).map(r => `<li>${r.title} <span class="pill">${(r.tags || []).join(', ')}</span></li>`).join('')}</ol>`;
      } catch (err) {
        themeResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    themeBtn.addEventListener('click', handleTheme);

    async function handleLogs() {
      try {
        logsBody.innerHTML = '<tr><td colspan="8">Loading‚Ä¶</td></tr>';
        const params = new URLSearchParams();
        if (logLimit.value.trim()) params.set('limit', logLimit.value.trim());
        if (logLevel.value.trim()) params.set('level', logLevel.value.trim());
        const data = await callJson(`/api/logs?${params.toString()}`, { headers: authHeaders() });
        logsBody.innerHTML = '';
        (data.items || []).forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${row.ts || ''}</td>
            <td>${row.level || ''}</td>
            <td>${row.route || ''}</td>
            <td>${row.method || ''}</td>
            <td>${row.status || ''}</td>
            <td>${row.ms || ''}</td>
            <td>${row.msg || ''}</td>
            <td><details><summary>meta</summary><pre>${JSON.stringify(row.meta || {}, null, 2)}</pre></details></td>`;
          logsBody.appendChild(tr);
        });
      } catch (err) {
        logsBody.innerHTML = `<tr><td colspan="8"><pre>${err.message}</pre></td></tr>`;
      }
    }
    refreshLogs.addEventListener('click', handleLogs);

    let mediaRecorder = null;
    let audioChunks = [];

    async function startRecording() {
      try {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordingStatus.hidden = false;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = event => { if (event.data.size) audioChunks.push(event.data); };
        mediaRecorder.onstop = async () => {
          recordingStatus.hidden = true;
          recordBtn.disabled = false;
          stopBtn.disabled = true;
          const blob = new Blob(audioChunks, { type: 'audio/webm' });
          const form = new FormData();
          form.append('file', blob, 'voice.webm');
          try {
            const res = await fetch('/api/transcribe', { method: 'POST', headers: authHeaders(), body: form });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || res.statusText);
            transcribeResult.textContent = data.text || '';
            ingredientsInput.value = data.text || ingredientsInput.value;
          } catch (err) {
            transcribeResult.textContent = err.message;
          }
        };
        mediaRecorder.start();
      } catch (err) {
        recordingStatus.hidden = true;
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        transcribeResult.textContent = err.message || 'Microphone permission denied.';
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }

    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);

    if (localStorage.getItem(API_KEY_STORAGE)) {
      handleLogs().catch(() => {});
    }
  </script>
</body>
</html>