<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Colby Recipe Backend</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f8f9fb;
      --fg: #222;
      --card: #ffffffcc;
      --accent: #2563eb;
      --muted: #55627a;
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      flex-direction: column;
      line-height: 1.5;
    }

    header {
      padding: 1.5rem 1rem 1rem;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.75rem;
    }

    header p {
      margin: 0;
      max-width: 720px;
      color: var(--muted);
    }

    main {
      flex: 1;
      display: grid;
      gap: 1.5rem;
      padding: 1.5rem clamp(1rem, 5vw, 3rem) 2rem;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }

    section {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 20px 45px rgba(15, 23, 42, 0.08);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    section h2 {
      margin: 0;
      font-size: 1.25rem;
    }

    a {
      color: var(--accent);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    ul {
      margin: 0;
      padding-left: 1.25rem;
    }

    .appliance-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .appliance-list li {
      background: rgba(148, 163, 184, 0.18);
      border-radius: 12px;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .appliance-meta {
      display: grid;
      gap: 0.25rem;
    }

    .appliance-actions {
      display: flex;
      gap: 0.5rem;
    }

    .stack {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .tester form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 0.25rem;
    }

    input[type="text"],
    input[type="url"],
    select,
    textarea {
      width: 100%;
      padding: 0.65rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(100, 116, 139, 0.35);
      font: inherit;
      background: rgba(255, 255, 255, 0.9);
      box-sizing: border-box;
    }

    textarea {
      min-height: 140px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Monaco, Consolas, monospace;
    }

    .headers {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .header-row {
      display: grid;
      grid-template-columns: minmax(110px, 1fr) minmax(120px, 1.5fr) auto;
      gap: 0.5rem;
      align-items: center;
    }

    .header-row input {
      width: 100%;
    }

    .header-row button {
      padding: 0.5rem;
      border: none;
      border-radius: 8px;
      background: rgba(148, 163, 184, 0.25);
      cursor: pointer;
    }

    .header-row button:hover {
      background: rgba(148, 163, 184, 0.4);
    }

    .actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .actions button {
      padding: 0.75rem 1.25rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
    }

    .actions button:disabled {
      opacity: 0.6;
      cursor: progress;
    }

    .response {
      background: rgba(15, 23, 42, 0.9);
      color: #f8fafc;
      padding: 1rem;
      border-radius: 12px;
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      overflow: hidden;
    }

    .response h3 {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .response pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(148, 163, 184, 0.16);
      padding: 0.75rem;
      border-radius: 10px;
      max-height: 260px;
      overflow: auto;
    }

    .streaming-log {
      max-height: 200px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Monaco, Consolas, monospace;
      font-size: 0.85rem;
    }

    .streaming-entry {
      padding: 0.5rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .streaming-entry:last-child {
      border-bottom: none;
    }

    .streaming-entry.processing {
      background: rgba(59, 130, 246, 0.1);
    }

    .streaming-entry.completed {
      background: rgba(34, 197, 94, 0.1);
    }

    .streaming-entry.failed {
      background: rgba(239, 68, 68, 0.1);
    }

    .streaming-entry.queued {
      background: rgba(156, 163, 175, 0.1);
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }

    .status-indicator.queued {
      background: #9ca3af;
    }

    .status-indicator.processing {
      background: #3b82f6;
      animation: pulse 2s infinite;
    }

    .status-indicator.completed {
      background: #22c55e;
    }

    .status-indicator.failed {
      background: #ef4444;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(148, 163, 184, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin: 0.5rem 0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #1d4ed8);
      border-radius: 2px;
      transition: width 0.3s ease;
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { background-position: -200px 0; }
      100% { background-position: calc(200px + 100%) 0; }
    }

    footer {
      padding: 1rem;
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (max-width: 720px) {
      main {
        grid-template-columns: 1fr;
      }

      .header-row {
        grid-template-columns: 1fr 1fr auto;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Colby Recipe Backend</h1>
    <p>Colby powers recipe ingestion, personalization, and menu planning for MenuForge. Use the authenticated REST API to scan recipes, manage favorites, build menus, and more. Explore the full schema in the <a href="/openapi.json">OpenAPI specification</a>.</p>
  </header>
  <main>
    <section>
      <h2>Quick Start</h2>
      <p>The Worker exposes a JSON API under <code>/api/</code> for recipes, favorites, menu generation, search utilities, and chat. Typical flow:</p>
      <ul>
        <li>Scan a recipe with <code>POST /api/recipes/scan</code> or <code>/batch-scan</code>.</li>
        <li>Query ranked recipes via <code>GET /api/recipes</code>.</li>
        <li>Track engagement with favorites, ratings, and custom events.</li>
        <li>Generate a weekly menu using <code>POST /api/menus/generate</code> with optional themes and exclusions.</li>
        <li>Keep pantry inventory in sync via <code>GET/POST/PUT/DELETE /api/pantry</code> and request a pantry-aware list with <code>POST /api/menus/{id}/shopping-list</code>.</li>
      </ul>
      <p>Responses are JSON unless otherwise noted (e.g., printable recipes return HTML). See <a href="/openapi.json">/openapi.json</a> for structured details.</p>
    </section>
    <section>
      <h2>Authentication</h2>
      <p>All API routes require the Worker API key.</p>
      <ul>
        <li><strong>Header:</strong> <code>Authorization: Bearer &lt;WORKER_API_KEY&gt;</code></li>
        <li><strong>or Header:</strong> <code>X-API-Key: &lt;WORKER_API_KEY&gt;</code></li>
      </ul>
      <p>When also sending user session tokens, prefer keeping <code>Authorization</code> for the session value and include the Worker key via <code>X-API-Key</code>. Unauthorized requests return <code>401</code> with <code>WWW-Authenticate: Bearer realm="worker"</code>. Store your key securely; the tester below keeps it in <code>localStorage</code> on this device only.</p>
    </section>
    <section class="tester">
      <h2>API Tester</h2>
      <form id="api-form">
        <div>
          <label for="path">Request path</label>
          <input id="path" name="path" type="text" value="/api/recipes" autocomplete="off" required>
        </div>
        <div>
          <label for="method">HTTP method</label>
          <select id="method" name="method">
            <option>GET</option>
            <option>POST</option>
            <option>PUT</option>
            <option>PATCH</option>
            <option>DELETE</option>
          </select>
        </div>
        <div>
          <label>Headers</label>
          <div class="headers" id="headers"></div>
          <div class="actions">
            <button type="button" id="add-header" style="background: rgba(148, 163, 184, 0.25); color: var(--fg);">Add header</button>
          </div>
        </div>
        <div>
          <label for="body">Request body (JSON)</label>
          <textarea id="body" name="body" placeholder='{"example":true}'></textarea>
        </div>
        <div class="actions">
          <button id="send" type="submit">Send request</button>
        </div>
      </form>
      <div class="response" id="response" hidden>
        <h3 id="response-status">Status</h3>
        <pre id="response-headers"></pre>
        <pre id="response-body"></pre>
      </div>
    </section>
    <section id="voice">
      <h2>Voice memo ‚Üí Ingredients</h2>
      <p>Record a short pantry rundown. We transcribe it and drop the text into the chat textarea.</p>
      <div class="row" style="align-items:center;">
        <button id="recordBtn">üéôÔ∏è Start recording</button>
        <span id="recordingStatus" class="pill" hidden>Recording‚Ä¶</span>
        <button id="stopBtn" class="secondary" disabled>‚èπ Stop</button>
      </div>
      <p id="transcribeResult"></p>
    </section>
  
    <section id="chat">
      <h2>On-hand chat</h2>
      <label for="ingredients">Ingredients (comma separated)</label>
      <textarea id="ingredients" placeholder="tomatoes, basil, mozzarella"></textarea>
      <label for="theme">Theme</label>
      <input id="theme" type="text" placeholder="e.g. summer picnic" />
      <div class="row">
        <div>
          <label for="userId">User ID (optional personalization)</label>
          <input id="userId" type="text" placeholder="household-123" />
        </div>
        <div>
          <label>Tools</label>
          <div class="tools">
            <label><input type="checkbox" value="air_fryer" class="toolChk" />Air fryer</label>
            <label><input type="checkbox" value="bread_machine" class="toolChk" />Bread machine</label>
            <label><input type="checkbox" value="slow_cooker" class="toolChk" />Slow cooker</label>
            <label><input type="checkbox" value="instant_pot" class="toolChk" />Instant Pot</label>
          </div>
        </div>
      </div>
      <button id="chatBtn">‚ú® Suggest recipes</button>
      <div id="chatOutput" style="margin-top:1rem;"></div>
    </section>
  
    <section id="ingestUrl">
      <h2>Ingest via URL</h2>
      <label for="urlInput">Recipe URL</label>
      <input id="urlInput" type="url" placeholder="https://example.com/my-favorite-recipe" />
      <button id="urlBtn">üåê Crawl &amp; normalize</button>
      <div id="urlResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="ingestImage">
      <h2>Ingest via image</h2>
      <p>Upload one or more recipe photos or scans. We run OCR and normalize the result.</p>
      <input id="imageInput" type="file" accept="image/*" multiple />
      <button id="imageBtn">üñºÔ∏è Normalize images</button>
      <div id="imageResult" style="margin-top:1rem;"></div>
    </section>

    <section id="collections">
      <h2>Favorites &amp; menus</h2>
      <p>Inspect the recipes and weekly menus saved for a given user session. Provide the user ID you want to scope.</p>
      <div class="flex-row items-end">
        <div style="flex:1 1 220px;">
          <label for="collectionsUserId">User ID</label>
          <input id="collectionsUserId" type="text" placeholder="household-123" />
        </div>
        <div class="actions" style="margin-top:0;">
          <button type="button" id="loadFavorites" class="secondary">‚≠ê Load favorites</button>
          <button type="button" id="loadMenus" class="secondary">üóìÔ∏è Load menus</button>
        </div>
      </div>
      <div id="favoritesResponse" class="response" hidden>
        <h3>Favorites</h3>
        <pre></pre>
      </div>
      <div id="menusResponse" class="response" hidden>
        <h3>Menus</h3>
        <pre></pre>
      </div>
    </section>

    <section id="manualRecipes">
      <h2>Manual recipe studio</h2>
      <p>Create or tweak recipes without scraping. Ingredients support optional quantities using <code>quantity | ingredient</code>.</p>
      <form id="createRecipeForm" class="stack">
        <h3>Create recipe</h3>
        <div style="display:flex; flex-wrap:wrap; gap:0.75rem;">
          <div style="flex:1 1 200px;">
            <label for="createRecipeUser">User ID</label>
            <input id="createRecipeUser" type="text" placeholder="household-123" required />
          </div>
          <div style="flex:1 1 200px;">
            <label for="createRecipeId">Recipe ID (optional)</label>
            <input id="createRecipeId" type="text" placeholder="manual-uuid" />
          </div>
        </div>
        <label for="createRecipeTitle">Title</label>
        <input id="createRecipeTitle" type="text" placeholder="Grandma&#39;s biscuits" required />
        <label for="createRecipeTags">Tags (comma separated)</label>
        <input id="createRecipeTags" type="text" placeholder="comfort,quick" />
        <label for="createRecipeTools">Tools (comma separated)</label>
        <input id="createRecipeTools" type="text" placeholder="cast iron,oven" />
        <div style="display:flex; flex-wrap:wrap; gap:0.75rem;">
          <div style="flex:1 1 120px;">
            <label for="createRecipePrepTime">Prep minutes</label>
            <input id="createRecipePrepTime" type="number" min="0" />
          </div>
          <div style="flex:1 1 120px;">
            <label for="createRecipeCookTime">Cook minutes</label>
            <input id="createRecipeCookTime" type="number" min="0" />
          </div>
        </div>
        <label for="createRecipeIngredients">Ingredients <small class="muted">One per line, e.g. <code>2 cups | Flour</code></small></label>
        <textarea id="createRecipeIngredients" rows="4" placeholder="2 cups | All-purpose flour&#10;1 tbsp | Baking powder" required></textarea>
        <label for="createRecipeSteps">Steps <small class="muted">One per line</small></label>
        <textarea id="createRecipeSteps" rows="4" placeholder="Preheat the oven to 425¬∞F&#10;Whisk dry ingredients together" required></textarea>
        <label for="createRecipeNotes">Notes</label>
        <textarea id="createRecipeNotes" rows="2" placeholder="Bakes best on the middle rack."></textarea>
        <button type="submit">‚ûï Create recipe</button>
      </form>
      <form id="updateRecipeForm" class="stack">
        <h3>Update recipe</h3>
        <div style="display:flex; flex-wrap:wrap; gap:0.75rem;">
          <div style="flex:1 1 200px;">
            <label for="updateRecipeUser">User ID</label>
            <input id="updateRecipeUser" type="text" placeholder="household-123" required />
          </div>
          <div style="flex:1 1 200px;">
            <label for="updateRecipeId">Recipe ID</label>
            <input id="updateRecipeId" type="text" placeholder="manual-uuid" required />
          </div>
        </div>
        <label for="updateRecipeTitle">Title</label>
        <input id="updateRecipeTitle" type="text" placeholder="Leave blank to keep" />
        <label for="updateRecipeTags">Tags (comma separated)</label>
        <input id="updateRecipeTags" type="text" placeholder="comfort,holiday" />
        <label for="updateRecipeTools">Tools (comma separated)</label>
        <input id="updateRecipeTools" type="text" placeholder="sheet pan,mixer" />
        <div style="display:flex; flex-wrap:wrap; gap:0.75rem;">
          <div style="flex:1 1 120px;">
            <label for="updateRecipePrepTime">Prep minutes</label>
            <input id="updateRecipePrepTime" type="number" min="0" />
          </div>
          <div style="flex:1 1 120px;">
            <label for="updateRecipeCookTime">Cook minutes</label>
            <input id="updateRecipeCookTime" type="number" min="0" />
          </div>
          <div style="flex:1 1 120px;">
            <label for="updateRecipeTotalTime">Total minutes</label>
            <input id="updateRecipeTotalTime" type="number" min="0" />
          </div>
        </div>
        <label for="updateRecipeIngredients">Ingredients override</label>
        <textarea id="updateRecipeIngredients" rows="3" placeholder="New ingredient list or leave blank"></textarea>
        <label for="updateRecipeSteps">Steps override</label>
        <textarea id="updateRecipeSteps" rows="3" placeholder="New steps or leave blank"></textarea>
        <label for="updateRecipeNotes">Notes</label>
        <textarea id="updateRecipeNotes" rows="2" placeholder="Leave blank to keep"></textarea>
        <button type="submit" class="secondary">‚úèÔ∏è Update recipe</button>
      </form>
      <div id="manualRecipeResponse" class="response" hidden>
        <h3>Manual recipe</h3>
        <pre></pre>
      </div>
    </section>

    <section id="appliances">
      <h2>Kitchen appliances</h2>
      <p>Upload manuals to personalize recipes for your gear. Manuals are stored securely in R2 and processed asynchronously. You can upload PDFs with pre-extracted text to skip OCR processing.</p>
      <form id="applianceForm" class="stack">
        <div>
          <label for="applianceNickname">Nickname (optional)</label>
          <input id="applianceNickname" type="text" placeholder="e.g. My Air Fryer" />
        </div>
        <div>
          <label for="applianceManual">Manual upload (PDF)</label>
          <input id="applianceManual" type="file" accept="application/pdf" />
        </div>
        <div>
          <label for="applianceTextFile">Pre-extracted text file (optional)</label>
          <input id="applianceTextFile" type="file" accept=".txt,.text" />
        </div>
        <div>
          <label for="applianceTextInput">Or paste text directly</label>
          <textarea id="applianceTextInput" placeholder="Paste extracted text here to skip OCR processing..." rows="4"></textarea>
        </div>
        <div>
          <label for="applianceManualUrl">Manual URL (public PDF)</label>
          <input id="applianceManualUrl" type="url" placeholder="https://example.com/manual.pdf" />
        </div>
        <p class="muted">Provide either a manual file or a public manual URL. Include text to skip OCR processing.</p>
        <div class="row" style="align-items:center; gap:0.75rem;">
          <button type="submit">‚ûï Add appliance</button>
          <button type="button" id="refreshAppliances" class="secondary">üîÑ Refresh list</button>
          <button type="button" id="toggleStreaming" class="secondary">üì° Toggle streaming</button>
        </div>
      </form>
      <div id="applianceResult" class="response" hidden>
        <h3>Latest appliance</h3>
        <pre id="applianceResultBody"></pre>
      </div>
      <div id="streamingStatus" class="response" hidden>
        <h3>üîÑ Live Processing Status</h3>
        <div id="streamingLog"></div>
      </div>
      <div>
        <h3>Your appliances</h3>
        <ul id="appliancesList" class="appliance-list">
          <li class="muted">No appliances yet. Add one to get started.</li>
        </ul>
      </div>
    </section>

    <section id="recipeAgents">
      <h2>Agentic recipe tailoring</h2>
      <p>Load structured recipes, generate Mermaid flowcharts, and rewrite instructions for a specific appliance.</p>
      <div class="row">
        <div>
          <label for="tailorRecipeId">Recipe ID</label>
          <input id="tailorRecipeId" type="text" placeholder="recipe-123" />
        </div>
        <div>
          <label for="tailorApplianceId">Appliance ID</label>
          <input id="tailorApplianceId" type="text" placeholder="appliance-456" />
        </div>
      </div>
      <div class="row" style="align-items:center; gap:0.75rem;">
        <button id="loadRecipeDetail" class="secondary">üìÑ Load recipe detail</button>
        <button id="flowchartBtn" class="secondary">üìà Generate flowchart</button>
        <button id="tailorBtn">ü§ñ Tailor instructions</button>
        <button id="adaptBtn" class="secondary">‚ú® Adapt instructions</button>
      </div>
      <div id="recipeDetailResult" class="response" hidden>
        <h3>Recipe detail</h3>
        <pre></pre>
      </div>
      <div id="flowchartResult" class="response" hidden>
        <h3>Mermaid flowchart</h3>
        <pre></pre>
      </div>
      <div id="tailorResult" class="response" hidden>
        <h3>Tailored steps</h3>
        <pre></pre>
      </div>
      <div id="adaptResult" class="response" hidden>
        <h3>Adapted recipe</h3>
        <pre></pre>
      </div>
    </section>

    <section id="pantry">
      <h2>Pantry Management</h2>
      <p>Manage your pantry inventory with receipt scanning and voice input.</p>
      
      <div class="stack">
        <h3>üìÑ Receipt Scanner</h3>
        <p>Upload a receipt image to automatically add items to your pantry.</p>
        <form id="receiptForm" class="stack">
          <div>
            <label for="receiptUser">User ID</label>
            <input id="receiptUser" type="text" placeholder="household-123" required />
          </div>
          <div>
            <label for="receiptFile">Receipt Image</label>
            <input id="receiptFile" type="file" accept="image/*" required />
          </div>
          <button type="submit">üì∑ Process Receipt</button>
        </form>
        <div id="receiptResult" class="response" hidden>
          <h3>Receipt Processing Result</h3>
          <pre id="receiptResultBody"></pre>
        </div>
      </div>

      <div class="stack">
        <h3>üéôÔ∏è Voice Pantry Update</h3>
        <p>Record your voice to describe what's in your pantry and automatically update your inventory.</p>
        <form id="voicePantryForm" class="stack">
          <div>
            <label for="voicePantryUser">User ID</label>
            <input id="voicePantryUser" type="text" placeholder="household-123" required />
          </div>
          <div class="row" style="align-items:center;">
            <button type="button" id="startVoiceRecording">üéôÔ∏è Start Recording</button>
            <span id="voiceRecordingStatus" class="pill" hidden>Recording‚Ä¶</span>
            <button type="button" id="stopVoiceRecording" class="secondary" disabled>‚èπ Stop</button>
          </div>
          <div id="voiceTranscriptionResult" class="response" hidden>
            <h3>Transcription & Pantry Update</h3>
            <pre id="voiceTranscriptionBody"></pre>
          </div>
        </form>
      </div>

      <div class="stack">
        <h3>üìù Manual Pantry Entry</h3>
        <p>Add items manually to your pantry.</p>
        <form id="manualPantryForm" class="stack">
          <div>
            <label for="manualPantryUser">User ID</label>
            <input id="manualPantryUser" type="text" placeholder="household-123" required />
          </div>
          <div>
            <label for="pantryItemName">Item Name</label>
            <input id="pantryItemName" type="text" placeholder="e.g. organic tomatoes" required />
          </div>
          <div class="row">
            <div>
              <label for="pantryItemQuantity">Quantity</label>
              <input id="pantryItemQuantity" type="text" placeholder="2" />
            </div>
            <div>
              <label for="pantryItemUnit">Unit</label>
              <input id="pantryItemUnit" type="text" placeholder="lbs" />
            </div>
          </div>
          <button type="submit">‚ûï Add to Pantry</button>
        </form>
        <div id="manualPantryResult" class="response" hidden>
          <h3>Pantry Item Added</h3>
          <pre id="manualPantryResultBody"></pre>
        </div>
      </div>

      <div>
        <h3>Your Pantry Items</h3>
        <div class="row" style="align-items:center; gap:0.75rem;">
          <button type="button" id="loadPantryItems" class="secondary">üîÑ Refresh Pantry</button>
        </div>
        <ul id="pantryItemsList" class="appliance-list">
          <li class="muted">No pantry items yet. Add some to get started.</li>
        </ul>
      </div>
    </section>

    <section id="prefs">
      <h2>User preferences</h2>
      <div class="row">
        <div>
          <label for="prefsUser">User ID</label>
          <input id="prefsUser" type="text" placeholder="household-123" />
        </div>
        <div>
          <label for="prefsCuisines">Favored cuisines</label>
          <input id="prefsCuisines" type="text" placeholder="thai, mexican" />
        </div>
        <div>
          <label for="prefsDislikes">Disliked ingredients</label>
          <input id="prefsDislikes" type="text" placeholder="olives, cilantro" />
        </div>
        <div>
          <label for="prefsTools">Favored tools</label>
          <input id="prefsTools" type="text" placeholder="air_fryer, grill" />
        </div>
      </div>
      <label for="prefsNotes">Notes</label>
      <textarea id="prefsNotes" placeholder="Anything else to remember"></textarea>
      <div class="row" style="margin-top:0.75rem;">
        <button id="loadPrefs">üì• Load</button>
        <button id="savePrefs" class="secondary">üíæ Save</button>
      </div>
      <div id="prefsResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="themes">
      <h2>Theme suggestions</h2>
      <label for="themeSeed">Theme seed</label>
      <input id="themeSeed" type="text" placeholder="peach" />
      <button id="themeBtn">üçë Fetch ideas</button>
      <div id="themeResult" style="margin-top:1rem;"></div>
    </section>
  
    <section id="logs">
      <h2>Request logs</h2>
      <div class="row" style="align-items:center;">
        <div>
          <label for="logLimit">Limit</label>
          <input id="logLimit" type="text" value="50" />
        </div>
        <div>
          <label for="logLevel">Level</label>
          <input id="logLevel" type="text" placeholder="info | error" />
        </div>
        <button id="refreshLogs">üîÑ Refresh</button>
      </div>
      <div style="overflow-x:auto; max-height:320px;">
        <table>
          <thead>
            <tr><th>Timestamp</th><th>Level</th><th>Route</th><th>Method</th><th>Status</th><th>ms</th><th>Message</th><th>Meta</th></tr>
          </thead>
          <tbody id="logsBody"></tbody>
        </table>
      </div>
    </section>
  </main>
  <footer>
    Built for MenuForge ‚Ä¢ Need schema details? <a href="/openapi.json">Download the OpenAPI document</a>.
  </footer>
  <script>
    const headersContainer = document.getElementById('headers');
    const addHeaderBtn = document.getElementById('add-header');
    const apiForm = document.getElementById('api-form');
    const methodSelect = document.getElementById('method');
    const bodyField = document.getElementById('body');
    const sendBtn = document.getElementById('send');
    const responseCard = document.getElementById('response');
    const responseStatus = document.getElementById('response-status');
    const responseHeaders = document.getElementById('response-headers');
    const responseBody = document.getElementById('response-body');
    const API_KEY_STORAGE = 'colby-api-key';

    function createHeaderRow(key = '', value = '', options = {}) {
      const row = document.createElement('div');
      row.className = 'header-row';

      const keyInput = document.createElement('input');
      keyInput.className = 'header-key';
      keyInput.type = 'text';
      keyInput.placeholder = 'Header name';
      keyInput.value = key;
      if (options.readonlyKey) {
        keyInput.readOnly = true;
        keyInput.tabIndex = -1;
        keyInput.style.background = 'rgba(148, 163, 184, 0.15)';
      }

      const valueInput = document.createElement('input');
      valueInput.className = 'header-value';
      valueInput.type = 'text';
      valueInput.placeholder = 'Header value';
      valueInput.value = value;

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = '‚úï';
      removeBtn.title = 'Remove header';
      removeBtn.addEventListener('click', () => row.remove());

      if (options.locked) {
        removeBtn.disabled = true;
        removeBtn.style.visibility = 'hidden';
      }

      row.appendChild(keyInput);
      row.appendChild(valueInput);
      row.appendChild(removeBtn);

      if (options.storageKey) {
        const saved = localStorage.getItem(options.storageKey);
        if (saved) {
          valueInput.value = saved;
        }
        valueInput.addEventListener('input', () => {
          localStorage.setItem(options.storageKey, valueInput.value);
        });
      }

      headersContainer.appendChild(row);
      return row;
    }

    createHeaderRow('X-API-Key', '', { storageKey: API_KEY_STORAGE });
    createHeaderRow('Content-Type', 'application/json');

    addHeaderBtn.addEventListener('click', () => {
      createHeaderRow();
    });

    methodSelect.addEventListener('change', () => {
      const method = methodSelect.value.toUpperCase();
      const allowBody = !['GET', 'HEAD'].includes(method);
      bodyField.disabled = !allowBody;
      if (!allowBody) {
        bodyField.placeholder = 'Request body not sent for ' + method + ' requests';
      } else {
        bodyField.placeholder = '{"example":true}';
      }
    });

    apiForm.addEventListener('submit', async (event) => {
      event.preventDefault();

      const rawPath = document.getElementById('path').value.trim();
      const method = methodSelect.value.toUpperCase();
      const headers = new Headers();

      headersContainer.querySelectorAll('.header-row').forEach((row) => {
        const key = row.querySelector('.header-key').value.trim();
        const value = row.querySelector('.header-value').value;
        if (key) {
          headers.set(key, value);
        }
      });

      let url;
      if (/^https?:\/\//i.test(rawPath)) {
        url = rawPath;
      } else {
        const normalized = rawPath.startsWith('/') ? rawPath : `/${rawPath}`;
        url = new URL(normalized, window.location.origin).toString();
      }

      let body = undefined;
      if (!['GET', 'HEAD'].includes(method)) {
        const content = bodyField.value.trim();
        if (content) {
          try {
            body = JSON.stringify(JSON.parse(content));
          } catch (error) {
            alert('Request body must be valid JSON.');
            return;
          }
        }
      }

      sendBtn.disabled = true;
      sendBtn.textContent = 'Sending‚Ä¶';
      responseCard.hidden = false;
      responseStatus.textContent = 'Awaiting response‚Ä¶';
      responseHeaders.textContent = '';
      responseBody.textContent = '';

      try {
        const res = await fetch(url, { method, headers, body });
        const statusLine = `${res.status} ${res.statusText}`;
        responseStatus.textContent = `Status: ${statusLine}`;

        const headerEntries = Array.from(res.headers.entries())
          .map(([k, v]) => `${k}: ${v}`)
          .join('\n');
        responseHeaders.textContent = headerEntries || '(no headers)';

        const text = await res.text();
        let formatted = text;
        try {
          formatted = JSON.stringify(JSON.parse(text), null, 2);
        } catch (error) {
          // Not JSON; leave as text
        }
        responseBody.textContent = formatted || '(empty body)';
      } catch (error) {
        responseStatus.textContent = 'Request failed';
        responseHeaders.textContent = '';
        responseBody.textContent = String(error);
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send request';
      }
    });

    const apiKeyInput = document.getElementById('apiKey');
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordingStatus = document.getElementById('recordingStatus');
    const transcribeResult = document.getElementById('transcribeResult');
    const ingredientsInput = document.getElementById('ingredients');
    const chatBtn = document.getElementById('chatBtn');
    const chatOutput = document.getElementById('chatOutput');
    const urlBtn = document.getElementById('urlBtn');
    const urlInput = document.getElementById('urlInput');
    const urlResult = document.getElementById('urlResult');
    const imageBtn = document.getElementById('imageBtn');
    const imageInput = document.getElementById('imageInput');
    const imageResult = document.getElementById('imageResult');
    const prefsUser = document.getElementById('prefsUser');
    const prefsCuisines = document.getElementById('prefsCuisines');
    const prefsDislikes = document.getElementById('prefsDislikes');
    const prefsTools = document.getElementById('prefsTools');
    const prefsNotes = document.getElementById('prefsNotes');
    const prefsResult = document.getElementById('prefsResult');
    const loadPrefs = document.getElementById('loadPrefs');
    const savePrefs = document.getElementById('savePrefs');
    const themeSeed = document.getElementById('themeSeed');
    const themeBtn = document.getElementById('themeBtn');
    const themeResult = document.getElementById('themeResult');
    const logsBody = document.getElementById('logsBody');
    const refreshLogs = document.getElementById('refreshLogs');
    const logLimit = document.getElementById('logLimit');
    const logLevel = document.getElementById('logLevel');
    const userIdInput = document.getElementById('userId');
    const toolCheckboxes = Array.from(document.querySelectorAll('.toolChk'));
    const themeInput = document.getElementById('theme');
    const applianceForm = document.getElementById('applianceForm');
    const applianceNickname = document.getElementById('applianceNickname');
    const applianceManual = document.getElementById('applianceManual');
    const applianceTextFile = document.getElementById('applianceTextFile');
    const applianceTextInput = document.getElementById('applianceTextInput');
    const applianceManualUrl = document.getElementById('applianceManualUrl');
    const applianceResult = document.getElementById('applianceResult');
    const applianceResultBody = document.getElementById('applianceResultBody');
    const appliancesList = document.getElementById('appliancesList');
    const refreshAppliances = document.getElementById('refreshAppliances');
    const toggleStreaming = document.getElementById('toggleStreaming');
    const streamingStatus = document.getElementById('streamingStatus');
    const streamingLog = document.getElementById('streamingLog');
    const recipeDetailResult = document.getElementById('recipeDetailResult');
    const recipeDetailPre = recipeDetailResult?.querySelector('pre');
    const flowchartResult = document.getElementById('flowchartResult');
    const flowchartPre = flowchartResult?.querySelector('pre');
    const tailorResult = document.getElementById('tailorResult');
    const tailorPre = tailorResult?.querySelector('pre');
    const adaptResult = document.getElementById('adaptResult');
    const adaptPre = adaptResult?.querySelector('pre');
    const loadRecipeDetailBtn = document.getElementById('loadRecipeDetail');
    const flowchartBtn = document.getElementById('flowchartBtn');
    const tailorBtnAgent = document.getElementById('tailorBtn');
    const adaptBtn = document.getElementById('adaptBtn');
    const tailorRecipeId = document.getElementById('tailorRecipeId');
    const tailorApplianceId = document.getElementById('tailorApplianceId');
    const collectionsUserId = document.getElementById('collectionsUserId');
    const loadFavoritesBtn = document.getElementById('loadFavorites');
    const loadMenusBtn = document.getElementById('loadMenus');
    const favoritesResponseCard = document.getElementById('favoritesResponse');
    const favoritesResponseBody = favoritesResponseCard?.querySelector('pre');
    const favoritesResponseTitle = favoritesResponseCard?.querySelector('h3');
    const menusResponseCard = document.getElementById('menusResponse');
    const menusResponseBody = menusResponseCard?.querySelector('pre');
    const menusResponseTitle = menusResponseCard?.querySelector('h3');
    const createRecipeForm = document.getElementById('createRecipeForm');
    const createRecipeUser = document.getElementById('createRecipeUser');
    const createRecipeId = document.getElementById('createRecipeId');
    const createRecipeTitle = document.getElementById('createRecipeTitle');
    const createRecipeTags = document.getElementById('createRecipeTags');
    const createRecipeTools = document.getElementById('createRecipeTools');
    const createRecipePrepTime = document.getElementById('createRecipePrepTime');
    const createRecipeCookTime = document.getElementById('createRecipeCookTime');
    const createRecipeIngredients = document.getElementById('createRecipeIngredients');
    const createRecipeSteps = document.getElementById('createRecipeSteps');
    const createRecipeNotes = document.getElementById('createRecipeNotes');
    const updateRecipeForm = document.getElementById('updateRecipeForm');
    const updateRecipeUser = document.getElementById('updateRecipeUser');
    const updateRecipeId = document.getElementById('updateRecipeId');
    const updateRecipeTitle = document.getElementById('updateRecipeTitle');
    const updateRecipeTags = document.getElementById('updateRecipeTags');
    const updateRecipeTools = document.getElementById('updateRecipeTools');
    const updateRecipePrepTime = document.getElementById('updateRecipePrepTime');
    const updateRecipeCookTime = document.getElementById('updateRecipeCookTime');
    const updateRecipeTotalTime = document.getElementById('updateRecipeTotalTime');
    const updateRecipeIngredients = document.getElementById('updateRecipeIngredients');
    const updateRecipeSteps = document.getElementById('updateRecipeSteps');
    const updateRecipeNotes = document.getElementById('updateRecipeNotes');
    const manualRecipeResponse = document.getElementById('manualRecipeResponse');
    const manualRecipeResponseTitle = manualRecipeResponse?.querySelector('h3');
    const manualRecipeResponseBody = manualRecipeResponse?.querySelector('pre');
    
    // Pantry management elements
    const receiptForm = document.getElementById('receiptForm');
    const receiptUser = document.getElementById('receiptUser');
    const receiptFile = document.getElementById('receiptFile');
    const receiptResult = document.getElementById('receiptResult');
    const receiptResultBody = document.getElementById('receiptResultBody');
    
    const voicePantryForm = document.getElementById('voicePantryForm');
    const voicePantryUser = document.getElementById('voicePantryUser');
    const startVoiceRecording = document.getElementById('startVoiceRecording');
    const stopVoiceRecording = document.getElementById('stopVoiceRecording');
    const voiceRecordingStatus = document.getElementById('voiceRecordingStatus');
    const voiceTranscriptionResult = document.getElementById('voiceTranscriptionResult');
    const voiceTranscriptionBody = document.getElementById('voiceTranscriptionBody');
    
    const manualPantryForm = document.getElementById('manualPantryForm');
    const manualPantryUser = document.getElementById('manualPantryUser');
    const pantryItemName = document.getElementById('pantryItemName');
    const pantryItemQuantity = document.getElementById('pantryItemQuantity');
    const pantryItemUnit = document.getElementById('pantryItemUnit');
    const manualPantryResult = document.getElementById('manualPantryResult');
    const manualPantryResultBody = document.getElementById('manualPantryResultBody');
    
    const loadPantryItems = document.getElementById('loadPantryItems');
    const pantryItemsList = document.getElementById('pantryItemsList');

    const storageKey = 'menuforge-api-key';
    
    function authHeaders(extra = {}) {
      const key = localStorage.getItem(API_KEY_STORAGE) || '';
      if (!key) throw new Error('API key required');
      return Object.assign({ 'X-API-Key': key }, extra);
    }

    function escapeHtml(value) {
      const str = value == null ? '' : String(value);
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    async function callJson(url, options = {}) {
      const res = await fetch(url, options);
      const data = await res.json().catch(() => ({}));
      if (!res.ok) throw new Error(data.error || res.statusText);
      return data;
    }

    function splitCommaList(value = '') {
      return value
        .split(',')
        .map((part) => part.trim())
        .filter(Boolean);
    }

    function parseMinutesInput(input, label) {
      if (!input) return undefined;
      const raw = (input.value || '').trim();
      if (!raw) return undefined;
      const parsed = Number(raw);
      if (!Number.isFinite(parsed)) {
        throw new Error(`${label} must be a number`);
      }
      return Math.round(parsed);
    }

    function parseIngredientLines(text) {
      return text
        .split('\n')
        .map((line) => line.trim())
        .filter(Boolean)
        .map((line) => {
          if (line.includes('|')) {
            const [quantity, ...rest] = line.split('|');
            const name = rest.join('|').trim();
            const qty = (quantity || '').trim();
            if (!name) {
              throw new Error('Ingredient lines must include a name after "|"');
            }
            return qty ? { name, quantity: qty } : { name };
          }
          return { name: line };
        });
    }

    function parseStepLines(text) {
      return text
        .split('\n')
        .map((line) => line.trim())
        .filter(Boolean)
        .map((instruction) => ({ instruction }));
    }

    function showManualRecipe(title, payload) {
      if (!manualRecipeResponse || !manualRecipeResponseTitle || !manualRecipeResponseBody) return;
      manualRecipeResponse.hidden = false;
      manualRecipeResponseTitle.textContent = title;
      manualRecipeResponseBody.textContent = JSON.stringify(payload, null, 2);
    }

    async function handleChat() {
      try {
        chatBtn.disabled = true;
        chatOutput.innerHTML = 'Loading‚Ä¶';
        const tools = toolCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
        const payload = {
          ingredients: ingredientsInput.value.split(',').map(s => s.trim()).filter(Boolean),
          theme: themeInput.value.trim() || undefined,
          tools,
          userId: userIdInput.value.trim() || undefined,
        };
        const data = await callJson('/api/chat/ingredients', {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        chatOutput.innerHTML = `
          <h3>Assistant message</h3>
          <pre>${data.message || ''}</pre>
          <h3>Suggestions</h3>
          <ol>${(data.suggestions || []).map(r => `<li><strong>${r.title}</strong> <small>${(r.cuisine || '')}</small><br/><span class="pill">${(r.tags || []).join(', ')}</span></li>`).join('')}</ol>
        `;
      } catch (err) {
        chatOutput.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        chatBtn.disabled = false;
      }
    }
    chatBtn.addEventListener('click', handleChat);

    async function handleUrl() {
      try {
        urlBtn.disabled = true;
        urlResult.textContent = 'Loading‚Ä¶';
        const data = await callJson('/api/ingest/url', {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ url: urlInput.value.trim() }),
        });
        urlResult.innerHTML = `<pre>${JSON.stringify(data.recipe, null, 2)}</pre>`;
      } catch (err) {
        urlResult.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        urlBtn.disabled = false;
      }
    }
    urlBtn.addEventListener('click', handleUrl);

    async function handleImages() {
      try {
        imageBtn.disabled = true;
        imageResult.textContent = 'Loading‚Ä¶';
        const form = new FormData();
        Array.from(imageInput.files || []).forEach(file => form.append('file', file));
        const res = await fetch('/api/ingest/image', {
          method: 'POST',
          headers: authHeaders(),
          body: form,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        imageResult.innerHTML = `<pre>${JSON.stringify(data.recipe, null, 2)}</pre>`;
      } catch (err) {
        imageResult.innerHTML = `<pre>${err.message}</pre>`;
      } finally {
        imageBtn.disabled = false;
      }
    }
    imageBtn.addEventListener('click', handleImages);

    async function handleLoadFavorites() {
      if (!collectionsUserId || !favoritesResponseCard || !favoritesResponseBody || !favoritesResponseTitle) return;
      const userId = collectionsUserId.value.trim();
      if (!userId) {
        favoritesResponseCard.hidden = false;
        favoritesResponseTitle.textContent = 'Favorites';
        favoritesResponseBody.textContent = 'User ID required';
        return;
      }
      try {
        if (loadFavoritesBtn) loadFavoritesBtn.disabled = true;
        favoritesResponseCard.hidden = false;
        favoritesResponseTitle.textContent = 'Favorites';
        favoritesResponseBody.textContent = 'Loading‚Ä¶';
        const data = await callJson(`/api/favorites?user_id=${encodeURIComponent(userId)}`, {
          headers: authHeaders(),
        });
        const count = Array.isArray(data) ? data.length : 0;
        favoritesResponseTitle.textContent = `${count} favorite${count === 1 ? '' : 's'}`;
        favoritesResponseBody.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        favoritesResponseBody.textContent = err.message;
      } finally {
        if (loadFavoritesBtn) loadFavoritesBtn.disabled = false;
      }
    }
    loadFavoritesBtn?.addEventListener('click', handleLoadFavorites);

    async function handleLoadMenus() {
      if (!collectionsUserId || !menusResponseCard || !menusResponseBody || !menusResponseTitle) return;
      const userId = collectionsUserId.value.trim();
      if (!userId) {
        menusResponseCard.hidden = false;
        menusResponseTitle.textContent = 'Menus';
        menusResponseBody.textContent = 'User ID required';
        return;
      }
      try {
        if (loadMenusBtn) loadMenusBtn.disabled = true;
        menusResponseCard.hidden = false;
        menusResponseTitle.textContent = 'Menus';
        menusResponseBody.textContent = 'Loading‚Ä¶';
        const data = await callJson(`/api/menus?user_id=${encodeURIComponent(userId)}`, {
          headers: authHeaders(),
        });
        const count = Array.isArray(data) ? data.length : 0;
        menusResponseTitle.textContent = `${count} menu${count === 1 ? '' : 's'}`;
        menusResponseBody.textContent = JSON.stringify(data, null, 2);
      } catch (err) {
        menusResponseBody.textContent = err.message;
      } finally {
        if (loadMenusBtn) loadMenusBtn.disabled = false;
      }
    }
    loadMenusBtn?.addEventListener('click', handleLoadMenus);

    function buildManualRecipePayload(options) {
      const payload = {
        title: options.title,
        ingredients: parseIngredientLines(options.ingredientsText),
        steps: parseStepLines(options.stepsText),
      };
      if (options.id) payload.id = options.id;
      if (options.tags?.length) payload.tags = options.tags;
      if (options.tools?.length) payload.tools = options.tools;
      if (options.prepMinutes !== undefined) payload.prepTimeMinutes = options.prepMinutes;
      if (options.cookMinutes !== undefined) payload.cookTimeMinutes = options.cookMinutes;
      if (options.totalMinutes !== undefined) payload.totalTimeMinutes = options.totalMinutes;
      if (options.notes) payload.notes = options.notes;
      return payload;
    }

    async function handleCreateRecipe(event) {
      event.preventDefault();
      if (!createRecipeForm) return;
      const submitBtn = createRecipeForm.querySelector('button[type="submit"]');
      try {
        submitBtn && (submitBtn.disabled = true);
        const userId = createRecipeUser?.value.trim();
        if (!userId) {
          throw new Error('User ID required');
        }
        const title = createRecipeTitle?.value.trim();
        if (!title) {
          throw new Error('Title required');
        }
        const ingredientsText = (createRecipeIngredients?.value || '').trim();
        if (!ingredientsText) {
          throw new Error('At least one ingredient required');
        }
        const stepsText = (createRecipeSteps?.value || '').trim();
        if (!stepsText) {
          throw new Error('At least one step required');
        }
        const payload = buildManualRecipePayload({
          title,
          id: createRecipeId?.value.trim() || undefined,
          ingredientsText,
          stepsText,
          tags: splitCommaList(createRecipeTags?.value || ''),
          tools: splitCommaList(createRecipeTools?.value || ''),
          prepMinutes: parseMinutesInput(createRecipePrepTime, 'Prep minutes'),
          cookMinutes: parseMinutesInput(createRecipeCookTime, 'Cook minutes'),
          notes: (createRecipeNotes?.value || '').trim() || undefined,
        });

        const data = await callJson(`/api/recipes?user_id=${encodeURIComponent(userId)}`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        showManualRecipe('Created recipe', data.recipe || data);
      } catch (err) {
        showManualRecipe('Error', { error: err.message });
      } finally {
        submitBtn && (submitBtn.disabled = false);
      }
    }
    createRecipeForm?.addEventListener('submit', handleCreateRecipe);

    async function handleUpdateRecipe(event) {
      event.preventDefault();
      if (!updateRecipeForm) return;
      const submitBtn = updateRecipeForm.querySelector('button[type="submit"]');
      try {
        submitBtn && (submitBtn.disabled = true);
        const userId = updateRecipeUser?.value.trim();
        if (!userId) {
          throw new Error('User ID required');
        }
        const recipeId = updateRecipeId?.value.trim();
        if (!recipeId) {
          throw new Error('Recipe ID required');
        }
        const payload = {};
        const title = updateRecipeTitle?.value.trim();
        if (title) payload.title = title;
        const tags = splitCommaList(updateRecipeTags?.value || '');
        if (tags.length) payload.tags = tags;
        const tools = splitCommaList(updateRecipeTools?.value || '');
        if (tools.length) payload.tools = tools;
        const prep = parseMinutesInput(updateRecipePrepTime, 'Prep minutes');
        if (prep !== undefined) payload.prepTimeMinutes = prep;
        const cook = parseMinutesInput(updateRecipeCookTime, 'Cook minutes');
        if (cook !== undefined) payload.cookTimeMinutes = cook;
        const total = parseMinutesInput(updateRecipeTotalTime, 'Total minutes');
        if (total !== undefined) payload.totalTimeMinutes = total;
        const ingredientsText = (updateRecipeIngredients?.value || '').trim();
        if (ingredientsText) {
          payload.ingredients = parseIngredientLines(ingredientsText);
        }
        const stepsText = (updateRecipeSteps?.value || '').trim();
        if (stepsText) {
          payload.steps = parseStepLines(stepsText);
        }
        const notes = (updateRecipeNotes?.value || '').trim();
        if (notes) {
          payload.notes = notes;
        }

        const data = await callJson(`/api/recipes/${encodeURIComponent(recipeId)}?user_id=${encodeURIComponent(userId)}`, {
          method: 'PUT',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        showManualRecipe('Updated recipe', data.recipe || data);
      } catch (err) {
        showManualRecipe('Error', { error: err.message });
      } finally {
        submitBtn && (submitBtn.disabled = false);
      }
    }
    updateRecipeForm?.addEventListener('submit', handleUpdateRecipe);

    async function loadAppliancesList() {
      if (!appliancesList) return;
      try {
        refreshAppliances && (refreshAppliances.disabled = true);
        const data = await callJson('/api/kitchen/appliances', { headers: authHeaders() });
        const items = data.appliances || [];
        if (!items.length) {
          appliancesList.innerHTML = '<li class="muted">No appliances yet. Add one to get started.</li>';
          return;
        }
        appliancesList.innerHTML = items
          .map((appliance) => {
            const specs = appliance.extractedSpecs || {};
            const displayName =
              appliance.nickname ||
              [appliance.brand || specs.brand, appliance.model || specs.model]
                .filter(Boolean)
                .join(' ') ||
              'Untitled appliance';
            const status = appliance.processingStatus || 'QUEUED';
            const safeStatus = escapeHtml(status);
            const manualKey = appliance.manualR2Key
              ? `Manual key: ${escapeHtml(appliance.manualR2Key)}`
              : 'Manual pending upload';
            const textKey = appliance.ocrTextR2Key ? `Text key: ${escapeHtml(appliance.ocrTextR2Key)}` : '';
            const features = Array.isArray(specs.keyFeatures) && specs.keyFeatures.length
              ? `<small>Features: ${specs.keyFeatures.map((f) => escapeHtml(f)).join(', ')}</small>`
              : '';
            const instructions = appliance.agentInstructions
              ? `<details><summary>Agent instructions</summary><pre>${escapeHtml(appliance.agentInstructions)}</pre></details>`
              : '';
            
            // Add streaming indicator for processing appliances
            const isStreamingThis = streamingAppliances.has(appliance.id);
            const statusButton = status === 'COMPLETED'
              ? ''
              : `<button data-action="status" data-id="${escapeHtml(appliance.id)}" class="secondary">üì° Check status</button>`;
            
            const streamingIndicator = isStreamingThis 
              ? '<span class="status-indicator processing" title="Live streaming"></span>' 
              : '';
            
            return `
              <li class="${status.toLowerCase()}">
                <div class="appliance-meta">
                  <strong>${streamingIndicator}${escapeHtml(displayName)}</strong>
                  <span class="pill ${status.toLowerCase()}">${safeStatus}</span>
                  <small>ID: ${escapeHtml(appliance.id)}</small>
                  <small>${manualKey}${textKey ? ` ¬∑ ${textKey}` : ''}</small>
                  ${features}
                  ${instructions}
                </div>
                <div class="appliance-actions">
                  ${statusButton}
                  <button data-action="delete" data-id="${escapeHtml(appliance.id)}" class="secondary">üóë Remove</button>
                </div>
              </li>`;
          })
          .join('');
      } catch (err) {
        appliancesList.innerHTML = `<li><pre>${err.message}</pre></li>`;
      } finally {
        refreshAppliances && (refreshAppliances.disabled = false);
      }
    }

    // Streaming functionality
    let streamingInterval = null;
    let isStreaming = false;
    const streamingAppliances = new Set();

    function addStreamingEntry(applianceId, status, message, timestamp = new Date()) {
      if (!streamingLog) return;
      
      const entry = document.createElement('div');
      entry.className = `streaming-entry ${status.toLowerCase()}`;
      entry.innerHTML = `
        <div>
          <span class="status-indicator ${status.toLowerCase()}"></span>
          <strong>${applianceId.substring(0, 8)}...</strong> ${message}
        </div>
        <div style="font-size: 0.75rem; color: var(--muted);">
          ${timestamp.toLocaleTimeString()}
        </div>
      `;
      
      streamingLog.insertBefore(entry, streamingLog.firstChild);
      
      // Keep only last 20 entries
      while (streamingLog.children.length > 20) {
        streamingLog.removeChild(streamingLog.lastChild);
      }
    }

    function startStreaming() {
      if (isStreaming) return;
      isStreaming = true;
      streamingStatus.hidden = false;
      toggleStreaming.textContent = '‚èπÔ∏è Stop streaming';
      
      streamingInterval = setInterval(async () => {
        if (streamingAppliances.size === 0) return;
        
        for (const applianceId of streamingAppliances) {
          try {
            const data = await callJson(`/api/kitchen/appliances/${applianceId}/status`, {
              headers: authHeaders(),
            });
            
            const status = data.status;
            if (status === 'COMPLETED' || status === 'FAILED') {
              streamingAppliances.delete(applianceId);
              addStreamingEntry(applianceId, status, status === 'COMPLETED' ? 'Processing completed!' : 'Processing failed');
            } else if (status === 'PROCESSING') {
              addStreamingEntry(applianceId, status, 'Processing in progress...');
            }
          } catch (err) {
            console.error('Streaming error:', err);
          }
        }
        
        // Refresh the appliances list to show updated statuses
        await loadAppliancesList();
      }, 2000); // Poll every 2 seconds
    }

    function stopStreaming() {
      if (!isStreaming) return;
      isStreaming = false;
      streamingStatus.hidden = true;
      toggleStreaming.textContent = 'üì° Toggle streaming';
      
      if (streamingInterval) {
        clearInterval(streamingInterval);
        streamingInterval = null;
      }
    }

    async function handleApplianceSubmit(event) {
      event.preventDefault();
      if (!applianceForm) return;
      try {
        applianceForm.querySelector('button[type="submit"]').disabled = true;
        const form = new FormData();
        const nickname = applianceNickname?.value.trim();
        const manualUrlValue = applianceManualUrl?.value.trim();
        const manualFile = applianceManual?.files && applianceManual.files[0];
        const textFile = applianceTextFile?.files && applianceTextFile.files[0];
        const textInput = applianceTextInput?.value.trim();

        if (!manualFile && !manualUrlValue && !textFile && !textInput) {
          throw new Error('Provide a manual file, manual URL, text file, or text input');
        }

        if (nickname) {
          form.append('nickname', nickname);
        }
        if (manualFile) {
          form.append('manual_file', manualFile);
        }
        if (textFile) {
          form.append('text_file', textFile);
        }
        if (textInput) {
          form.append('text', textInput);
        }
        if (manualUrlValue) {
          form.append('manual_url', manualUrlValue);
        }
        
        const res = await fetch('/api/kitchen/appliances', {
          method: 'POST',
          headers: authHeaders(),
          body: form,
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        
        if (applianceResult && applianceResultBody) {
          applianceResult.hidden = false;
          applianceResultBody.textContent = JSON.stringify(data, null, 2);
        }
        
        // Add to streaming if processing
        if (data.appliance_id) {
          streamingAppliances.add(data.appliance_id);
          addStreamingEntry(data.appliance_id, 'QUEUED', 'Upload successful, queued for processing');
          
          // Auto-start streaming if not already running
          if (!isStreaming) {
            startStreaming();
          }
        }
        
        applianceForm.reset();
        await loadAppliancesList();
      } catch (err) {
        if (applianceResult && applianceResultBody) {
          applianceResult.hidden = false;
          applianceResultBody.textContent = err.message;
        }
      } finally {
        const submitBtn = applianceForm.querySelector('button[type="submit"]');
        submitBtn && (submitBtn.disabled = false);
      }
    }

    async function handleDeleteAppliance(id) {
      try {
        await callJson(`/api/kitchen/appliances/${id}`, {
          method: 'DELETE',
          headers: authHeaders(),
        });
        await loadAppliancesList();
      } catch (err) {
        alert(err.message);
      }
    }

    async function handleApplianceStatus(id) {
      try {
        const data = await callJson(`/api/kitchen/appliances/${id}/status`, {
          headers: authHeaders(),
        });
        alert(`Status: ${data.status}`);
        await loadAppliancesList();
      } catch (err) {
        alert(err.message);
      }
    }

    appliancesList?.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const id = target.dataset.id;
      if (target.dataset.action === 'delete' && id) {
        handleDeleteAppliance(id);
      }
      if (target.dataset.action === 'status' && id) {
        handleApplianceStatus(id);
      }
    });

    applianceForm?.addEventListener('submit', handleApplianceSubmit);
    refreshAppliances?.addEventListener('click', loadAppliancesList);
    toggleStreaming?.addEventListener('click', () => {
      if (isStreaming) {
        stopStreaming();
      } else {
        startStreaming();
      }
    });

    async function handleRecipeDetailLoad() {
      if (!recipeDetailResult || !recipeDetailPre) return;
      try {
        loadRecipeDetailBtn.disabled = true;
        recipeDetailResult.hidden = false;
        recipeDetailPre.textContent = 'Loading‚Ä¶';
        const id = tailorRecipeId.value.trim();
        if (!id) throw new Error('Recipe ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(id)}`, {
          headers: authHeaders(),
        });
        recipeDetailPre.textContent = JSON.stringify(data.recipe, null, 2);
      } catch (err) {
        recipeDetailPre.textContent = err.message;
      } finally {
        loadRecipeDetailBtn.disabled = false;
      }
    }

    loadRecipeDetailBtn?.addEventListener('click', handleRecipeDetailLoad);

    async function handleFlowchart() {
      if (!flowchartResult || !flowchartPre) return;
      try {
        flowchartBtn.disabled = true;
        flowchartResult.hidden = false;
        flowchartPre.textContent = 'Loading‚Ä¶';
        const id = tailorRecipeId.value.trim();
        if (!id) throw new Error('Recipe ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(id)}/flowchart`, {
          headers: authHeaders(),
        });
        flowchartPre.textContent = data.flowchart || '';
      } catch (err) {
        flowchartPre.textContent = err.message;
      } finally {
        flowchartBtn.disabled = false;
      }
    }

    flowchartBtn?.addEventListener('click', handleFlowchart);

    async function handleTailorRecipe() {
      if (!tailorResult || !tailorPre) return;
      try {
        tailorBtnAgent.disabled = true;
        tailorResult.hidden = false;
        tailorPre.textContent = 'Loading‚Ä¶';
        const recipeId = tailorRecipeId.value.trim();
        const applianceId = tailorApplianceId.value.trim();
        if (!recipeId) throw new Error('Recipe ID required');
        if (!applianceId) throw new Error('Appliance ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(recipeId)}/tailor`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ appliance_id: applianceId }),
        });
        const steps = data.tailored_steps || [];
        tailorPre.textContent = steps.length ? steps.map((step, index) => `${index + 1}. ${step}`).join('\n') : 'No steps returned.';
      } catch (err) {
        tailorPre.textContent = err.message;
      } finally {
        tailorBtnAgent.disabled = false;
      }
    }

    tailorBtnAgent?.addEventListener('click', handleTailorRecipe);

    async function handleAdaptRecipe() {
      if (!adaptResult || !adaptPre) return;
      try {
        adaptBtn.disabled = true;
        adaptResult.hidden = false;
        adaptPre.textContent = 'Loading‚Ä¶';
        const recipeId = tailorRecipeId.value.trim();
        const applianceId = tailorApplianceId.value.trim();
        if (!recipeId) throw new Error('Recipe ID required');
        if (!applianceId) throw new Error('Appliance ID required');
        const data = await callJson(`/api/recipes/${encodeURIComponent(recipeId)}/adapt`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify({ appliance_id: applianceId }),
        });
        const steps = data.tailored_steps || [];
        const summary = data.summary_of_changes || '';
        const stepsText = steps.length
          ? steps.map((step, index) => `${index + 1}. ${step}`).join('\n')
          : 'No steps returned.';
        adaptPre.textContent = `${summary ? `Summary: ${summary}\n\n` : ''}${stepsText}`;
      } catch (err) {
        adaptPre.textContent = err.message;
      } finally {
        adaptBtn.disabled = false;
      }
    }

    adaptBtn?.addEventListener('click', handleAdaptRecipe);

    async function handlePrefsLoad() {
      try {
        prefsResult.textContent = 'Loading‚Ä¶';
        const params = new URLSearchParams({ userId: prefsUser.value.trim() });
        const data = await callJson(`/api/prefs?${params.toString()}`, { headers: authHeaders() });
        const prefs = data.preferences || {};
        prefsCuisines.value = (prefs.cuisines || []).join(', ');
        prefsDislikes.value = (prefs.dislikedIngredients || []).join(', ');
        prefsTools.value = (prefs.favoredTools || []).join(', ');
        prefsNotes.value = prefs.notes || '';
        prefsResult.innerHTML = `<pre>${JSON.stringify(prefs, null, 2)}</pre>`;
      } catch (err) {
        prefsResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    loadPrefs.addEventListener('click', handlePrefsLoad);

    async function handlePrefsSave() {
      try {
        prefsResult.textContent = 'Saving‚Ä¶';
        const payload = {
          userId: prefsUser.value.trim(),
          cuisines: prefsCuisines.value,
          dislikedIngredients: prefsDislikes.value,
          favoredTools: prefsTools.value,
          notes: prefsNotes.value,
        };
        const data = await callJson('/api/prefs', {
          method: 'PUT',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        prefsResult.innerHTML = `<pre>${JSON.stringify(data.preferences, null, 2)}</pre>`;
      } catch (err) {
        prefsResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    savePrefs.addEventListener('click', handlePrefsSave);

    async function handleTheme() {
      try {
        themeResult.textContent = 'Loading‚Ä¶';
        const params = new URLSearchParams({ seed: themeSeed.value.trim() });
        const data = await callJson(`/api/themes/suggest?${params.toString()}`, { headers: authHeaders() });
        themeResult.innerHTML = `<ol>${(data.recipes || []).map(r => `<li>${r.title} <span class="pill">${(r.tags || []).join(', ')}</span></li>`).join('')}</ol>`;
      } catch (err) {
        themeResult.innerHTML = `<pre>${err.message}</pre>`;
      }
    }
    themeBtn.addEventListener('click', handleTheme);

    async function handleLogs() {
      try {
        logsBody.innerHTML = '<tr><td colspan="8">Loading‚Ä¶</td></tr>';
        const params = new URLSearchParams();
        if (logLimit.value.trim()) params.set('limit', logLimit.value.trim());
        if (logLevel.value.trim()) params.set('level', logLevel.value.trim());
        const data = await callJson(`/api/logs?${params.toString()}`, { headers: authHeaders() });
        logsBody.innerHTML = '';
        (data.items || []).forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${row.ts || ''}</td>
            <td>${row.level || ''}</td>
            <td>${row.route || ''}</td>
            <td>${row.method || ''}</td>
            <td>${row.status || ''}</td>
            <td>${row.ms || ''}</td>
            <td>${row.msg || ''}</td>
            <td><details><summary>meta</summary><pre>${JSON.stringify(row.meta || {}, null, 2)}</pre></details></td>`;
          logsBody.appendChild(tr);
        });
      } catch (err) {
        logsBody.innerHTML = `<tr><td colspan="8"><pre>${err.message}</pre></td></tr>`;
      }
    }
    refreshLogs.addEventListener('click', handleLogs);

    // Pantry management functions
    async function handleReceiptUpload(event) {
      event.preventDefault();
      if (!receiptForm) return;
      
      try {
        const submitBtn = receiptForm.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        
        const userId = receiptUser?.value.trim();
        const file = receiptFile?.files?.[0];
        
        if (!userId) {
          throw new Error('User ID required');
        }
        if (!file) {
          throw new Error('Receipt file required');
        }
        
        const form = new FormData();
        form.append('receipt', file);
        
        const res = await fetch('/api/pantry/receipt', {
          method: 'POST',
          headers: authHeaders(),
          body: form,
        });
        
        const data = await res.json();
        if (!res.ok) throw new Error(data.error || res.statusText);
        
        if (receiptResult && receiptResultBody) {
          receiptResult.hidden = false;
          receiptResultBody.textContent = JSON.stringify(data, null, 2);
        }
        
        // Refresh pantry list
        await loadPantryItemsList();
      } catch (err) {
        if (receiptResult && receiptResultBody) {
          receiptResult.hidden = false;
          receiptResultBody.textContent = err.message;
        }
      } finally {
        const submitBtn = receiptForm.querySelector('button[type="submit"]');
        submitBtn && (submitBtn.disabled = false);
      }
    }

    async function handleManualPantryAdd(event) {
      event.preventDefault();
      if (!manualPantryForm) return;
      
      try {
        const submitBtn = manualPantryForm.querySelector('button[type="submit"]');
        submitBtn.disabled = true;
        
        const userId = manualPantryUser?.value.trim();
        const name = pantryItemName?.value.trim();
        const quantity = pantryItemQuantity?.value.trim();
        const unit = pantryItemUnit?.value.trim();
        
        if (!userId) {
          throw new Error('User ID required');
        }
        if (!name) {
          throw new Error('Item name required');
        }
        
        const payload = {
          ingredientName: name,
          quantity: quantity || null,
          unit: unit || null,
        };
        
        const data = await callJson(`/api/pantry?user_id=${encodeURIComponent(userId)}`, {
          method: 'POST',
          headers: authHeaders({ 'Content-Type': 'application/json' }),
          body: JSON.stringify(payload),
        });
        
        if (manualPantryResult && manualPantryResultBody) {
          manualPantryResult.hidden = false;
          manualPantryResultBody.textContent = JSON.stringify(data, null, 2);
        }
        
        // Clear form
        manualPantryForm.reset();
        
        // Refresh pantry list
        await loadPantryItemsList();
      } catch (err) {
        if (manualPantryResult && manualPantryResultBody) {
          manualPantryResult.hidden = false;
          manualPantryResultBody.textContent = err.message;
        }
      } finally {
        const submitBtn = manualPantryForm.querySelector('button[type="submit"]');
        submitBtn && (submitBtn.disabled = false);
      }
    }

    async function loadPantryItemsList() {
      if (!pantryItemsList) return;
      
      try {
        const userId = voicePantryUser?.value.trim() || receiptUser?.value.trim() || manualPantryUser?.value.trim();
        if (!userId) {
          pantryItemsList.innerHTML = '<li class="muted">Enter a User ID to load pantry items.</li>';
          return;
        }
        
        const data = await callJson(`/api/pantry?user_id=${encodeURIComponent(userId)}`, {
          headers: authHeaders(),
        });
        
        const items = data.items || [];
        if (!items.length) {
          pantryItemsList.innerHTML = '<li class="muted">No pantry items yet. Add some to get started.</li>';
          return;
        }
        
        pantryItemsList.innerHTML = items
          .map((item) => {
            const quantity = item.quantity ? ` ${item.quantity}` : '';
            const unit = item.unit ? ` ${item.unit}` : '';
            return `
              <li>
                <div class="appliance-meta">
                  <strong>${escapeHtml(item.ingredientName)}</strong>
                  <small>${quantity}${unit}</small>
                  <small>ID: ${item.id}</small>
                </div>
                <div class="appliance-actions">
                  <button data-action="delete-pantry" data-id="${item.id}" class="secondary">üóë Remove</button>
                </div>
              </li>`;
          })
          .join('');
      } catch (err) {
        pantryItemsList.innerHTML = `<li><pre>${err.message}</pre></li>`;
      }
    }

    async function handleDeletePantryItem(id) {
      try {
        await callJson(`/api/pantry/${id}`, {
          method: 'DELETE',
          headers: authHeaders(),
        });
        await loadPantryItemsList();
      } catch (err) {
        alert(err.message);
      }
    }

    // Voice recording for pantry
    let voiceMediaRecorder = null;
    let voiceAudioChunks = [];

    async function startVoiceRecording() {
      try {
        startVoiceRecording.disabled = true;
        stopVoiceRecording.disabled = false;
        voiceRecordingStatus.hidden = false;
        
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        voiceAudioChunks = [];
        voiceMediaRecorder = new MediaRecorder(stream);
        
        voiceMediaRecorder.ondataavailable = event => { 
          if (event.data.size) voiceAudioChunks.push(event.data); 
        };
        
        voiceMediaRecorder.onstop = async () => {
          voiceRecordingStatus.hidden = true;
          startVoiceRecording.disabled = false;
          stopVoiceRecording.disabled = true;
          
          const blob = new Blob(voiceAudioChunks, { type: 'audio/webm' });
          const form = new FormData();
          form.append('audio', blob, 'voice.webm');
          form.append('action', 'update_pantry');
          
          try {
            const res = await fetch('/api/transcribe/voice', { 
              method: 'POST', 
              headers: authHeaders(), 
              body: form 
            });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || res.statusText);
            
            if (voiceTranscriptionResult && voiceTranscriptionBody) {
              voiceTranscriptionResult.hidden = false;
              voiceTranscriptionBody.textContent = JSON.stringify(data, null, 2);
            }
            
            // Refresh pantry list
            await loadPantryItemsList();
          } catch (err) {
            if (voiceTranscriptionResult && voiceTranscriptionBody) {
              voiceTranscriptionResult.hidden = false;
              voiceTranscriptionBody.textContent = err.message;
            }
          }
        };
        
        voiceMediaRecorder.start();
      } catch (err) {
        voiceRecordingStatus.hidden = true;
        startVoiceRecording.disabled = false;
        stopVoiceRecording.disabled = true;
        alert(err.message || 'Microphone permission denied.');
      }
    }

    function stopVoiceRecording() {
      if (voiceMediaRecorder && voiceMediaRecorder.state !== 'inactive') {
        voiceMediaRecorder.stop();
      }
    }

    // Event listeners
    receiptForm?.addEventListener('submit', handleReceiptUpload);
    manualPantryForm?.addEventListener('submit', handleManualPantryAdd);
    loadPantryItems?.addEventListener('click', loadPantryItemsList);
    startVoiceRecording?.addEventListener('click', startVoiceRecording);
    stopVoiceRecording?.addEventListener('click', stopVoiceRecording);

    // Handle pantry item deletion
    pantryItemsList?.addEventListener('click', (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const id = target.dataset.id;
      if (target.dataset.action === 'delete-pantry' && id) {
        handleDeletePantryItem(id);
      }
    });

    let mediaRecorder = null;
    let audioChunks = [];

    async function startRecording() {
      try {
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        recordingStatus.hidden = false;
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = event => { if (event.data.size) audioChunks.push(event.data); };
        mediaRecorder.onstop = async () => {
          recordingStatus.hidden = true;
          recordBtn.disabled = false;
          stopBtn.disabled = true;
          const blob = new Blob(audioChunks, { type: 'audio/webm' });
          const form = new FormData();
          form.append('file', blob, 'voice.webm');
          try {
            const res = await fetch('/api/transcribe', { method: 'POST', headers: authHeaders(), body: form });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error || res.statusText);
            transcribeResult.textContent = data.text || '';
            ingredientsInput.value = data.text || ingredientsInput.value;
          } catch (err) {
            transcribeResult.textContent = err.message;
          }
        };
        mediaRecorder.start();
      } catch (err) {
        recordingStatus.hidden = true;
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        transcribeResult.textContent = err.message || 'Microphone permission denied.';
      }
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }

    recordBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);

    if (localStorage.getItem(API_KEY_STORAGE)) {
      handleLogs().catch(() => {});
    }
  </script>
</body>
</html>